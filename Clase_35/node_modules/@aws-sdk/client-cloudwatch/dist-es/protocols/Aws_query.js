import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { collectBody, decorateServiceException as __decorateServiceException, expectNonNull as __expectNonNull, expectString as __expectString, extendedEncodeURIComponent as __extendedEncodeURIComponent, getArrayIfSingleItem as __getArrayIfSingleItem, getValueFromTextNode as __getValueFromTextNode, parseBoolean as __parseBoolean, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, serializeFloat as __serializeFloat, strictParseFloat as __strictParseFloat, strictParseInt32 as __strictParseInt32, strictParseLong as __strictParseLong, withBaseException, } from "@smithy/smithy-client";
import { XMLParser } from "fast-xml-parser";
import { CloudWatchServiceException as __BaseException } from "../models/CloudWatchServiceException";
import { ConcurrentModificationException, DashboardInvalidInputError, DashboardNotFoundError, InternalServiceFault, InvalidFormatFault, InvalidNextToken, InvalidParameterCombinationException, InvalidParameterValueException, LimitExceededException, LimitExceededFault, MissingRequiredParameterException, ResourceNotFound, ResourceNotFoundException, } from "../models/models_0";
export const se_DeleteAlarmsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteAlarmsInput(input, context),
        Action: "DeleteAlarms",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteAnomalyDetectorCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteAnomalyDetectorInput(input, context),
        Action: "DeleteAnomalyDetector",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteDashboardsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteDashboardsInput(input, context),
        Action: "DeleteDashboards",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteInsightRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteInsightRulesInput(input, context),
        Action: "DeleteInsightRules",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteMetricStreamCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteMetricStreamInput(input, context),
        Action: "DeleteMetricStream",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAlarmHistoryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAlarmHistoryInput(input, context),
        Action: "DescribeAlarmHistory",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAlarmsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAlarmsInput(input, context),
        Action: "DescribeAlarms",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAlarmsForMetricCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAlarmsForMetricInput(input, context),
        Action: "DescribeAlarmsForMetric",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAnomalyDetectorsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAnomalyDetectorsInput(input, context),
        Action: "DescribeAnomalyDetectors",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeInsightRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeInsightRulesInput(input, context),
        Action: "DescribeInsightRules",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableAlarmActionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableAlarmActionsInput(input, context),
        Action: "DisableAlarmActions",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisableInsightRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DisableInsightRulesInput(input, context),
        Action: "DisableInsightRules",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableAlarmActionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableAlarmActionsInput(input, context),
        Action: "EnableAlarmActions",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableInsightRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableInsightRulesInput(input, context),
        Action: "EnableInsightRules",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetDashboardCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetDashboardInput(input, context),
        Action: "GetDashboard",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetInsightRuleReportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetInsightRuleReportInput(input, context),
        Action: "GetInsightRuleReport",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetMetricDataCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetMetricDataInput(input, context),
        Action: "GetMetricData",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetMetricStatisticsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetMetricStatisticsInput(input, context),
        Action: "GetMetricStatistics",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetMetricStreamCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetMetricStreamInput(input, context),
        Action: "GetMetricStream",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetMetricWidgetImageCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetMetricWidgetImageInput(input, context),
        Action: "GetMetricWidgetImage",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListDashboardsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListDashboardsInput(input, context),
        Action: "ListDashboards",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListManagedInsightRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListManagedInsightRulesInput(input, context),
        Action: "ListManagedInsightRules",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListMetricsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListMetricsInput(input, context),
        Action: "ListMetrics",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListMetricStreamsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListMetricStreamsInput(input, context),
        Action: "ListMetricStreams",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListTagsForResourceInput(input, context),
        Action: "ListTagsForResource",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutAnomalyDetectorCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutAnomalyDetectorInput(input, context),
        Action: "PutAnomalyDetector",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutCompositeAlarmCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutCompositeAlarmInput(input, context),
        Action: "PutCompositeAlarm",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutDashboardCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutDashboardInput(input, context),
        Action: "PutDashboard",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutInsightRuleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutInsightRuleInput(input, context),
        Action: "PutInsightRule",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutManagedInsightRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutManagedInsightRulesInput(input, context),
        Action: "PutManagedInsightRules",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutMetricAlarmCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutMetricAlarmInput(input, context),
        Action: "PutMetricAlarm",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutMetricDataCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutMetricDataInput(input, context),
        Action: "PutMetricData",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutMetricStreamCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutMetricStreamInput(input, context),
        Action: "PutMetricStream",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SetAlarmStateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetAlarmStateInput(input, context),
        Action: "SetAlarmState",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartMetricStreamsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_StartMetricStreamsInput(input, context),
        Action: "StartMetricStreams",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StopMetricStreamsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_StopMetricStreamsInput(input, context),
        Action: "StopMetricStreams",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TagResourceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagResourceInput(input, context),
        Action: "TagResource",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UntagResourceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagResourceInput(input, context),
        Action: "UntagResource",
        Version: "2010-08-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_DeleteAlarmsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteAlarmsCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteAlarmsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceNotFound":
        case "com.amazonaws.cloudwatch#ResourceNotFound":
            throw await de_ResourceNotFoundRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteAnomalyDetectorCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteAnomalyDetectorCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteAnomalyDetectorOutput(data.DeleteAnomalyDetectorResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeleteAnomalyDetectorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterCombination":
        case "com.amazonaws.cloudwatch#InvalidParameterCombinationException":
            throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatch#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteDashboardsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteDashboardsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteDashboardsOutput(data.DeleteDashboardsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeleteDashboardsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "ResourceNotFound":
        case "com.amazonaws.cloudwatch#DashboardNotFoundError":
            throw await de_DashboardNotFoundErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteInsightRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteInsightRulesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteInsightRulesOutput(data.DeleteInsightRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeleteInsightRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteMetricStreamCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteMetricStreamCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteMetricStreamOutput(data.DeleteMetricStreamResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeleteMetricStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeAlarmHistoryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAlarmHistoryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAlarmHistoryOutput(data.DescribeAlarmHistoryResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeAlarmHistoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.cloudwatch#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeAlarmsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAlarmsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAlarmsOutput(data.DescribeAlarmsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeAlarmsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.cloudwatch#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeAlarmsForMetricCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAlarmsForMetricCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAlarmsForMetricOutput(data.DescribeAlarmsForMetricResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeAlarmsForMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DescribeAnomalyDetectorsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAnomalyDetectorsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAnomalyDetectorsOutput(data.DescribeAnomalyDetectorsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeAnomalyDetectorsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.cloudwatch#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "InvalidParameterCombination":
        case "com.amazonaws.cloudwatch#InvalidParameterCombinationException":
            throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DescribeInsightRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeInsightRulesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeInsightRulesOutput(data.DescribeInsightRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DescribeInsightRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.cloudwatch#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DisableAlarmActionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DisableAlarmActionsCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DisableAlarmActionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_DisableInsightRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DisableInsightRulesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DisableInsightRulesOutput(data.DisableInsightRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DisableInsightRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_EnableAlarmActionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_EnableAlarmActionsCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_EnableAlarmActionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_EnableInsightRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_EnableInsightRulesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_EnableInsightRulesOutput(data.EnableInsightRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_EnableInsightRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cloudwatch#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetDashboardCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetDashboardCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetDashboardOutput(data.GetDashboardResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetDashboardCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "ResourceNotFound":
        case "com.amazonaws.cloudwatch#DashboardNotFoundError":
            throw await de_DashboardNotFoundErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetInsightRuleReportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetInsightRuleReportCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetInsightRuleReportOutput(data.GetInsightRuleReportResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetInsightRuleReportCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatch#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetMetricDataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetMetricDataCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMetricDataOutput(data.GetMetricDataResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetMetricDataCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.cloudwatch#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetMetricStatisticsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetMetricStatisticsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMetricStatisticsOutput(data.GetMetricStatisticsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetMetricStatisticsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterCombination":
        case "com.amazonaws.cloudwatch#InvalidParameterCombinationException":
            throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetMetricStreamCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetMetricStreamCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMetricStreamOutput(data.GetMetricStreamResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetMetricStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterCombination":
        case "com.amazonaws.cloudwatch#InvalidParameterCombinationException":
            throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatch#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetMetricWidgetImageCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetMetricWidgetImageCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMetricWidgetImageOutput(data.GetMetricWidgetImageResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetMetricWidgetImageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_ListDashboardsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListDashboardsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListDashboardsOutput(data.ListDashboardsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListDashboardsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListManagedInsightRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListManagedInsightRulesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListManagedInsightRulesOutput(data.ListManagedInsightRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListManagedInsightRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidNextToken":
        case "com.amazonaws.cloudwatch#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListMetricsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListMetricsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListMetricsOutput(data.ListMetricsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListMetricsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListMetricStreamsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListMetricStreamsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListMetricStreamsOutput(data.ListMetricStreamsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListMetricStreamsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidNextToken":
        case "com.amazonaws.cloudwatch#InvalidNextToken":
            throw await de_InvalidNextTokenRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListTagsForResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListTagsForResourceOutput(data.ListTagsForResourceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatch#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_PutAnomalyDetectorCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutAnomalyDetectorCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutAnomalyDetectorOutput(data.PutAnomalyDetectorResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_PutAnomalyDetectorCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterCombination":
        case "com.amazonaws.cloudwatch#InvalidParameterCombinationException":
            throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cloudwatch#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_PutCompositeAlarmCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutCompositeAlarmCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_PutCompositeAlarmCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.cloudwatch#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_PutDashboardCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutDashboardCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutDashboardOutput(data.PutDashboardResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_PutDashboardCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterInput":
        case "com.amazonaws.cloudwatch#DashboardInvalidInputError":
            throw await de_DashboardInvalidInputErrorRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_PutInsightRuleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutInsightRuleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutInsightRuleOutput(data.PutInsightRuleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_PutInsightRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cloudwatch#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_PutManagedInsightRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutManagedInsightRulesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutManagedInsightRulesOutput(data.PutManagedInsightRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_PutManagedInsightRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_PutMetricAlarmCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutMetricAlarmCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_PutMetricAlarmCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.cloudwatch#LimitExceededFault":
            throw await de_LimitExceededFaultRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_PutMetricDataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutMetricDataCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_PutMetricDataCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterCombination":
        case "com.amazonaws.cloudwatch#InvalidParameterCombinationException":
            throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_PutMetricStreamCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutMetricStreamCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PutMetricStreamOutput(data.PutMetricStreamResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_PutMetricStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.cloudwatch#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterCombination":
        case "com.amazonaws.cloudwatch#InvalidParameterCombinationException":
            throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_SetAlarmStateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SetAlarmStateCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_SetAlarmStateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidFormat":
        case "com.amazonaws.cloudwatch#InvalidFormatFault":
            throw await de_InvalidFormatFaultRes(parsedOutput, context);
        case "ResourceNotFound":
        case "com.amazonaws.cloudwatch#ResourceNotFound":
            throw await de_ResourceNotFoundRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_StartMetricStreamsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StartMetricStreamsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StartMetricStreamsOutput(data.StartMetricStreamsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_StartMetricStreamsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_StopMetricStreamsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_StopMetricStreamsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StopMetricStreamsOutput(data.StopMetricStreamsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_StopMetricStreamsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "MissingParameter":
        case "com.amazonaws.cloudwatch#MissingRequiredParameterException":
            throw await de_MissingRequiredParameterExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_TagResourceOutput(data.TagResourceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.cloudwatch#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatch#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UntagResourceOutput(data.UntagResourceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.cloudwatch#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InternalServiceError":
        case "com.amazonaws.cloudwatch#InternalServiceFault":
            throw await de_InternalServiceFaultRes(parsedOutput, context);
        case "InvalidParameterValue":
        case "com.amazonaws.cloudwatch#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cloudwatch#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ConcurrentModificationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ConcurrentModificationException(body.Error, context);
    const exception = new ConcurrentModificationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DashboardInvalidInputErrorRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DashboardInvalidInputError(body.Error, context);
    const exception = new DashboardInvalidInputError({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DashboardNotFoundErrorRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DashboardNotFoundError(body.Error, context);
    const exception = new DashboardNotFoundError({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InternalServiceFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InternalServiceFault(body.Error, context);
    const exception = new InternalServiceFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidFormatFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidFormatFault(body.Error, context);
    const exception = new InvalidFormatFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidNextTokenRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidNextToken(body.Error, context);
    const exception = new InvalidNextToken({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidParameterCombinationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidParameterCombinationException(body.Error, context);
    const exception = new InvalidParameterCombinationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidParameterValueExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidParameterValueException(body.Error, context);
    const exception = new InvalidParameterValueException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_LimitExceededException(body.Error, context);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_LimitExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_LimitExceededFault(body.Error, context);
    const exception = new LimitExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_MissingRequiredParameterExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_MissingRequiredParameterException(body.Error, context);
    const exception = new MissingRequiredParameterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceNotFoundRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceNotFound(body.Error, context);
    const exception = new ResourceNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceNotFoundException(body.Error, context);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_AlarmNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AlarmTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AnomalyDetectorConfiguration = (input, context) => {
    const entries = {};
    if (input.ExcludedTimeRanges != null) {
        const memberEntries = se_AnomalyDetectorExcludedTimeRanges(input.ExcludedTimeRanges, context);
        if (input.ExcludedTimeRanges?.length === 0) {
            entries.ExcludedTimeRanges = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExcludedTimeRanges.${key}`;
            entries[loc] = value;
        });
    }
    if (input.MetricTimezone != null) {
        entries["MetricTimezone"] = input.MetricTimezone;
    }
    return entries;
};
const se_AnomalyDetectorExcludedTimeRanges = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Range(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_AnomalyDetectorTypes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Counts = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = __serializeFloat(entry);
        counter++;
    }
    return entries;
};
const se_DashboardNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_DeleteAlarmsInput = (input, context) => {
    const entries = {};
    if (input.AlarmNames != null) {
        const memberEntries = se_AlarmNames(input.AlarmNames, context);
        if (input.AlarmNames?.length === 0) {
            entries.AlarmNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteAnomalyDetectorInput = (input, context) => {
    const entries = {};
    if (input.Namespace != null) {
        entries["Namespace"] = input.Namespace;
    }
    if (input.MetricName != null) {
        entries["MetricName"] = input.MetricName;
    }
    if (input.Dimensions != null) {
        const memberEntries = se_Dimensions(input.Dimensions, context);
        if (input.Dimensions?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Stat != null) {
        entries["Stat"] = input.Stat;
    }
    if (input.SingleMetricAnomalyDetector != null) {
        const memberEntries = se_SingleMetricAnomalyDetector(input.SingleMetricAnomalyDetector, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SingleMetricAnomalyDetector.${key}`;
            entries[loc] = value;
        });
    }
    if (input.MetricMathAnomalyDetector != null) {
        const memberEntries = se_MetricMathAnomalyDetector(input.MetricMathAnomalyDetector, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricMathAnomalyDetector.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteDashboardsInput = (input, context) => {
    const entries = {};
    if (input.DashboardNames != null) {
        const memberEntries = se_DashboardNames(input.DashboardNames, context);
        if (input.DashboardNames?.length === 0) {
            entries.DashboardNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DashboardNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteInsightRulesInput = (input, context) => {
    const entries = {};
    if (input.RuleNames != null) {
        const memberEntries = se_InsightRuleNames(input.RuleNames, context);
        if (input.RuleNames?.length === 0) {
            entries.RuleNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RuleNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteMetricStreamInput = (input, context) => {
    const entries = {};
    if (input.Name != null) {
        entries["Name"] = input.Name;
    }
    return entries;
};
const se_DescribeAlarmHistoryInput = (input, context) => {
    const entries = {};
    if (input.AlarmName != null) {
        entries["AlarmName"] = input.AlarmName;
    }
    if (input.AlarmTypes != null) {
        const memberEntries = se_AlarmTypes(input.AlarmTypes, context);
        if (input.AlarmTypes?.length === 0) {
            entries.AlarmTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmTypes.${key}`;
            entries[loc] = value;
        });
    }
    if (input.HistoryItemType != null) {
        entries["HistoryItemType"] = input.HistoryItemType;
    }
    if (input.StartDate != null) {
        entries["StartDate"] = input.StartDate.toISOString().split(".")[0] + "Z";
    }
    if (input.EndDate != null) {
        entries["EndDate"] = input.EndDate.toISOString().split(".")[0] + "Z";
    }
    if (input.MaxRecords != null) {
        entries["MaxRecords"] = input.MaxRecords;
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.ScanBy != null) {
        entries["ScanBy"] = input.ScanBy;
    }
    return entries;
};
const se_DescribeAlarmsForMetricInput = (input, context) => {
    const entries = {};
    if (input.MetricName != null) {
        entries["MetricName"] = input.MetricName;
    }
    if (input.Namespace != null) {
        entries["Namespace"] = input.Namespace;
    }
    if (input.Statistic != null) {
        entries["Statistic"] = input.Statistic;
    }
    if (input.ExtendedStatistic != null) {
        entries["ExtendedStatistic"] = input.ExtendedStatistic;
    }
    if (input.Dimensions != null) {
        const memberEntries = se_Dimensions(input.Dimensions, context);
        if (input.Dimensions?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Period != null) {
        entries["Period"] = input.Period;
    }
    if (input.Unit != null) {
        entries["Unit"] = input.Unit;
    }
    return entries;
};
const se_DescribeAlarmsInput = (input, context) => {
    const entries = {};
    if (input.AlarmNames != null) {
        const memberEntries = se_AlarmNames(input.AlarmNames, context);
        if (input.AlarmNames?.length === 0) {
            entries.AlarmNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AlarmNamePrefix != null) {
        entries["AlarmNamePrefix"] = input.AlarmNamePrefix;
    }
    if (input.AlarmTypes != null) {
        const memberEntries = se_AlarmTypes(input.AlarmTypes, context);
        if (input.AlarmTypes?.length === 0) {
            entries.AlarmTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmTypes.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ChildrenOfAlarmName != null) {
        entries["ChildrenOfAlarmName"] = input.ChildrenOfAlarmName;
    }
    if (input.ParentsOfAlarmName != null) {
        entries["ParentsOfAlarmName"] = input.ParentsOfAlarmName;
    }
    if (input.StateValue != null) {
        entries["StateValue"] = input.StateValue;
    }
    if (input.ActionPrefix != null) {
        entries["ActionPrefix"] = input.ActionPrefix;
    }
    if (input.MaxRecords != null) {
        entries["MaxRecords"] = input.MaxRecords;
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const se_DescribeAnomalyDetectorsInput = (input, context) => {
    const entries = {};
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.MaxResults != null) {
        entries["MaxResults"] = input.MaxResults;
    }
    if (input.Namespace != null) {
        entries["Namespace"] = input.Namespace;
    }
    if (input.MetricName != null) {
        entries["MetricName"] = input.MetricName;
    }
    if (input.Dimensions != null) {
        const memberEntries = se_Dimensions(input.Dimensions, context);
        if (input.Dimensions?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AnomalyDetectorTypes != null) {
        const memberEntries = se_AnomalyDetectorTypes(input.AnomalyDetectorTypes, context);
        if (input.AnomalyDetectorTypes?.length === 0) {
            entries.AnomalyDetectorTypes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AnomalyDetectorTypes.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeInsightRulesInput = (input, context) => {
    const entries = {};
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.MaxResults != null) {
        entries["MaxResults"] = input.MaxResults;
    }
    return entries;
};
const se_Dimension = (input, context) => {
    const entries = {};
    if (input.Name != null) {
        entries["Name"] = input.Name;
    }
    if (input.Value != null) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const se_DimensionFilter = (input, context) => {
    const entries = {};
    if (input.Name != null) {
        entries["Name"] = input.Name;
    }
    if (input.Value != null) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const se_DimensionFilters = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_DimensionFilter(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Dimensions = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Dimension(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_DisableAlarmActionsInput = (input, context) => {
    const entries = {};
    if (input.AlarmNames != null) {
        const memberEntries = se_AlarmNames(input.AlarmNames, context);
        if (input.AlarmNames?.length === 0) {
            entries.AlarmNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DisableInsightRulesInput = (input, context) => {
    const entries = {};
    if (input.RuleNames != null) {
        const memberEntries = se_InsightRuleNames(input.RuleNames, context);
        if (input.RuleNames?.length === 0) {
            entries.RuleNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RuleNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_EnableAlarmActionsInput = (input, context) => {
    const entries = {};
    if (input.AlarmNames != null) {
        const memberEntries = se_AlarmNames(input.AlarmNames, context);
        if (input.AlarmNames?.length === 0) {
            entries.AlarmNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_EnableInsightRulesInput = (input, context) => {
    const entries = {};
    if (input.RuleNames != null) {
        const memberEntries = se_InsightRuleNames(input.RuleNames, context);
        if (input.RuleNames?.length === 0) {
            entries.RuleNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RuleNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ExtendedStatistics = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_GetDashboardInput = (input, context) => {
    const entries = {};
    if (input.DashboardName != null) {
        entries["DashboardName"] = input.DashboardName;
    }
    return entries;
};
const se_GetInsightRuleReportInput = (input, context) => {
    const entries = {};
    if (input.RuleName != null) {
        entries["RuleName"] = input.RuleName;
    }
    if (input.StartTime != null) {
        entries["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
    }
    if (input.EndTime != null) {
        entries["EndTime"] = input.EndTime.toISOString().split(".")[0] + "Z";
    }
    if (input.Period != null) {
        entries["Period"] = input.Period;
    }
    if (input.MaxContributorCount != null) {
        entries["MaxContributorCount"] = input.MaxContributorCount;
    }
    if (input.Metrics != null) {
        const memberEntries = se_InsightRuleMetricList(input.Metrics, context);
        if (input.Metrics?.length === 0) {
            entries.Metrics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metrics.${key}`;
            entries[loc] = value;
        });
    }
    if (input.OrderBy != null) {
        entries["OrderBy"] = input.OrderBy;
    }
    return entries;
};
const se_GetMetricDataInput = (input, context) => {
    const entries = {};
    if (input.MetricDataQueries != null) {
        const memberEntries = se_MetricDataQueries(input.MetricDataQueries, context);
        if (input.MetricDataQueries?.length === 0) {
            entries.MetricDataQueries = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricDataQueries.${key}`;
            entries[loc] = value;
        });
    }
    if (input.StartTime != null) {
        entries["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
    }
    if (input.EndTime != null) {
        entries["EndTime"] = input.EndTime.toISOString().split(".")[0] + "Z";
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.ScanBy != null) {
        entries["ScanBy"] = input.ScanBy;
    }
    if (input.MaxDatapoints != null) {
        entries["MaxDatapoints"] = input.MaxDatapoints;
    }
    if (input.LabelOptions != null) {
        const memberEntries = se_LabelOptions(input.LabelOptions, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LabelOptions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_GetMetricStatisticsInput = (input, context) => {
    const entries = {};
    if (input.Namespace != null) {
        entries["Namespace"] = input.Namespace;
    }
    if (input.MetricName != null) {
        entries["MetricName"] = input.MetricName;
    }
    if (input.Dimensions != null) {
        const memberEntries = se_Dimensions(input.Dimensions, context);
        if (input.Dimensions?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.StartTime != null) {
        entries["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
    }
    if (input.EndTime != null) {
        entries["EndTime"] = input.EndTime.toISOString().split(".")[0] + "Z";
    }
    if (input.Period != null) {
        entries["Period"] = input.Period;
    }
    if (input.Statistics != null) {
        const memberEntries = se_Statistics(input.Statistics, context);
        if (input.Statistics?.length === 0) {
            entries.Statistics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Statistics.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ExtendedStatistics != null) {
        const memberEntries = se_ExtendedStatistics(input.ExtendedStatistics, context);
        if (input.ExtendedStatistics?.length === 0) {
            entries.ExtendedStatistics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExtendedStatistics.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Unit != null) {
        entries["Unit"] = input.Unit;
    }
    return entries;
};
const se_GetMetricStreamInput = (input, context) => {
    const entries = {};
    if (input.Name != null) {
        entries["Name"] = input.Name;
    }
    return entries;
};
const se_GetMetricWidgetImageInput = (input, context) => {
    const entries = {};
    if (input.MetricWidget != null) {
        entries["MetricWidget"] = input.MetricWidget;
    }
    if (input.OutputFormat != null) {
        entries["OutputFormat"] = input.OutputFormat;
    }
    return entries;
};
const se_InsightRuleMetricList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_InsightRuleNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LabelOptions = (input, context) => {
    const entries = {};
    if (input.Timezone != null) {
        entries["Timezone"] = input.Timezone;
    }
    return entries;
};
const se_ListDashboardsInput = (input, context) => {
    const entries = {};
    if (input.DashboardNamePrefix != null) {
        entries["DashboardNamePrefix"] = input.DashboardNamePrefix;
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    return entries;
};
const se_ListManagedInsightRulesInput = (input, context) => {
    const entries = {};
    if (input.ResourceARN != null) {
        entries["ResourceARN"] = input.ResourceARN;
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.MaxResults != null) {
        entries["MaxResults"] = input.MaxResults;
    }
    return entries;
};
const se_ListMetricsInput = (input, context) => {
    const entries = {};
    if (input.Namespace != null) {
        entries["Namespace"] = input.Namespace;
    }
    if (input.MetricName != null) {
        entries["MetricName"] = input.MetricName;
    }
    if (input.Dimensions != null) {
        const memberEntries = se_DimensionFilters(input.Dimensions, context);
        if (input.Dimensions?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.RecentlyActive != null) {
        entries["RecentlyActive"] = input.RecentlyActive;
    }
    if (input.IncludeLinkedAccounts != null) {
        entries["IncludeLinkedAccounts"] = input.IncludeLinkedAccounts;
    }
    if (input.OwningAccount != null) {
        entries["OwningAccount"] = input.OwningAccount;
    }
    return entries;
};
const se_ListMetricStreamsInput = (input, context) => {
    const entries = {};
    if (input.NextToken != null) {
        entries["NextToken"] = input.NextToken;
    }
    if (input.MaxResults != null) {
        entries["MaxResults"] = input.MaxResults;
    }
    return entries;
};
const se_ListTagsForResourceInput = (input, context) => {
    const entries = {};
    if (input.ResourceARN != null) {
        entries["ResourceARN"] = input.ResourceARN;
    }
    return entries;
};
const se_ManagedRule = (input, context) => {
    const entries = {};
    if (input.TemplateName != null) {
        entries["TemplateName"] = input.TemplateName;
    }
    if (input.ResourceARN != null) {
        entries["ResourceARN"] = input.ResourceARN;
    }
    if (input.Tags != null) {
        const memberEntries = se_TagList(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ManagedRules = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ManagedRule(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Metric = (input, context) => {
    const entries = {};
    if (input.Namespace != null) {
        entries["Namespace"] = input.Namespace;
    }
    if (input.MetricName != null) {
        entries["MetricName"] = input.MetricName;
    }
    if (input.Dimensions != null) {
        const memberEntries = se_Dimensions(input.Dimensions, context);
        if (input.Dimensions?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_MetricData = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricDatum(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_MetricDataQueries = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricDataQuery(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_MetricDataQuery = (input, context) => {
    const entries = {};
    if (input.Id != null) {
        entries["Id"] = input.Id;
    }
    if (input.MetricStat != null) {
        const memberEntries = se_MetricStat(input.MetricStat, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricStat.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Expression != null) {
        entries["Expression"] = input.Expression;
    }
    if (input.Label != null) {
        entries["Label"] = input.Label;
    }
    if (input.ReturnData != null) {
        entries["ReturnData"] = input.ReturnData;
    }
    if (input.Period != null) {
        entries["Period"] = input.Period;
    }
    if (input.AccountId != null) {
        entries["AccountId"] = input.AccountId;
    }
    return entries;
};
const se_MetricDatum = (input, context) => {
    const entries = {};
    if (input.MetricName != null) {
        entries["MetricName"] = input.MetricName;
    }
    if (input.Dimensions != null) {
        const memberEntries = se_Dimensions(input.Dimensions, context);
        if (input.Dimensions?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Timestamp != null) {
        entries["Timestamp"] = input.Timestamp.toISOString().split(".")[0] + "Z";
    }
    if (input.Value != null) {
        entries["Value"] = __serializeFloat(input.Value);
    }
    if (input.StatisticValues != null) {
        const memberEntries = se_StatisticSet(input.StatisticValues, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `StatisticValues.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Values != null) {
        const memberEntries = se_Values(input.Values, context);
        if (input.Values?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Counts != null) {
        const memberEntries = se_Counts(input.Counts, context);
        if (input.Counts?.length === 0) {
            entries.Counts = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Counts.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Unit != null) {
        entries["Unit"] = input.Unit;
    }
    if (input.StorageResolution != null) {
        entries["StorageResolution"] = input.StorageResolution;
    }
    return entries;
};
const se_MetricMathAnomalyDetector = (input, context) => {
    const entries = {};
    if (input.MetricDataQueries != null) {
        const memberEntries = se_MetricDataQueries(input.MetricDataQueries, context);
        if (input.MetricDataQueries?.length === 0) {
            entries.MetricDataQueries = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricDataQueries.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_MetricStat = (input, context) => {
    const entries = {};
    if (input.Metric != null) {
        const memberEntries = se_Metric(input.Metric, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metric.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Period != null) {
        entries["Period"] = input.Period;
    }
    if (input.Stat != null) {
        entries["Stat"] = input.Stat;
    }
    if (input.Unit != null) {
        entries["Unit"] = input.Unit;
    }
    return entries;
};
const se_MetricStreamFilter = (input, context) => {
    const entries = {};
    if (input.Namespace != null) {
        entries["Namespace"] = input.Namespace;
    }
    if (input.MetricNames != null) {
        const memberEntries = se_MetricStreamFilterMetricNames(input.MetricNames, context);
        if (input.MetricNames?.length === 0) {
            entries.MetricNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_MetricStreamFilterMetricNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_MetricStreamFilters = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricStreamFilter(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_MetricStreamNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_MetricStreamStatisticsAdditionalStatistics = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_MetricStreamStatisticsConfiguration = (input, context) => {
    const entries = {};
    if (input.IncludeMetrics != null) {
        const memberEntries = se_MetricStreamStatisticsIncludeMetrics(input.IncludeMetrics, context);
        if (input.IncludeMetrics?.length === 0) {
            entries.IncludeMetrics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IncludeMetrics.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AdditionalStatistics != null) {
        const memberEntries = se_MetricStreamStatisticsAdditionalStatistics(input.AdditionalStatistics, context);
        if (input.AdditionalStatistics?.length === 0) {
            entries.AdditionalStatistics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AdditionalStatistics.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_MetricStreamStatisticsConfigurations = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricStreamStatisticsConfiguration(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_MetricStreamStatisticsIncludeMetrics = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_MetricStreamStatisticsMetric(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_MetricStreamStatisticsMetric = (input, context) => {
    const entries = {};
    if (input.Namespace != null) {
        entries["Namespace"] = input.Namespace;
    }
    if (input.MetricName != null) {
        entries["MetricName"] = input.MetricName;
    }
    return entries;
};
const se_PutAnomalyDetectorInput = (input, context) => {
    const entries = {};
    if (input.Namespace != null) {
        entries["Namespace"] = input.Namespace;
    }
    if (input.MetricName != null) {
        entries["MetricName"] = input.MetricName;
    }
    if (input.Dimensions != null) {
        const memberEntries = se_Dimensions(input.Dimensions, context);
        if (input.Dimensions?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Stat != null) {
        entries["Stat"] = input.Stat;
    }
    if (input.Configuration != null) {
        const memberEntries = se_AnomalyDetectorConfiguration(input.Configuration, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Configuration.${key}`;
            entries[loc] = value;
        });
    }
    if (input.SingleMetricAnomalyDetector != null) {
        const memberEntries = se_SingleMetricAnomalyDetector(input.SingleMetricAnomalyDetector, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SingleMetricAnomalyDetector.${key}`;
            entries[loc] = value;
        });
    }
    if (input.MetricMathAnomalyDetector != null) {
        const memberEntries = se_MetricMathAnomalyDetector(input.MetricMathAnomalyDetector, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricMathAnomalyDetector.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PutCompositeAlarmInput = (input, context) => {
    const entries = {};
    if (input.ActionsEnabled != null) {
        entries["ActionsEnabled"] = input.ActionsEnabled;
    }
    if (input.AlarmActions != null) {
        const memberEntries = se_ResourceList(input.AlarmActions, context);
        if (input.AlarmActions?.length === 0) {
            entries.AlarmActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AlarmDescription != null) {
        entries["AlarmDescription"] = input.AlarmDescription;
    }
    if (input.AlarmName != null) {
        entries["AlarmName"] = input.AlarmName;
    }
    if (input.AlarmRule != null) {
        entries["AlarmRule"] = input.AlarmRule;
    }
    if (input.InsufficientDataActions != null) {
        const memberEntries = se_ResourceList(input.InsufficientDataActions, context);
        if (input.InsufficientDataActions?.length === 0) {
            entries.InsufficientDataActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InsufficientDataActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.OKActions != null) {
        const memberEntries = se_ResourceList(input.OKActions, context);
        if (input.OKActions?.length === 0) {
            entries.OKActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `OKActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Tags != null) {
        const memberEntries = se_TagList(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ActionsSuppressor != null) {
        entries["ActionsSuppressor"] = input.ActionsSuppressor;
    }
    if (input.ActionsSuppressorWaitPeriod != null) {
        entries["ActionsSuppressorWaitPeriod"] = input.ActionsSuppressorWaitPeriod;
    }
    if (input.ActionsSuppressorExtensionPeriod != null) {
        entries["ActionsSuppressorExtensionPeriod"] = input.ActionsSuppressorExtensionPeriod;
    }
    return entries;
};
const se_PutDashboardInput = (input, context) => {
    const entries = {};
    if (input.DashboardName != null) {
        entries["DashboardName"] = input.DashboardName;
    }
    if (input.DashboardBody != null) {
        entries["DashboardBody"] = input.DashboardBody;
    }
    return entries;
};
const se_PutInsightRuleInput = (input, context) => {
    const entries = {};
    if (input.RuleName != null) {
        entries["RuleName"] = input.RuleName;
    }
    if (input.RuleState != null) {
        entries["RuleState"] = input.RuleState;
    }
    if (input.RuleDefinition != null) {
        entries["RuleDefinition"] = input.RuleDefinition;
    }
    if (input.Tags != null) {
        const memberEntries = se_TagList(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PutManagedInsightRulesInput = (input, context) => {
    const entries = {};
    if (input.ManagedRules != null) {
        const memberEntries = se_ManagedRules(input.ManagedRules, context);
        if (input.ManagedRules?.length === 0) {
            entries.ManagedRules = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ManagedRules.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PutMetricAlarmInput = (input, context) => {
    const entries = {};
    if (input.AlarmName != null) {
        entries["AlarmName"] = input.AlarmName;
    }
    if (input.AlarmDescription != null) {
        entries["AlarmDescription"] = input.AlarmDescription;
    }
    if (input.ActionsEnabled != null) {
        entries["ActionsEnabled"] = input.ActionsEnabled;
    }
    if (input.OKActions != null) {
        const memberEntries = se_ResourceList(input.OKActions, context);
        if (input.OKActions?.length === 0) {
            entries.OKActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `OKActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AlarmActions != null) {
        const memberEntries = se_ResourceList(input.AlarmActions, context);
        if (input.AlarmActions?.length === 0) {
            entries.AlarmActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlarmActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.InsufficientDataActions != null) {
        const memberEntries = se_ResourceList(input.InsufficientDataActions, context);
        if (input.InsufficientDataActions?.length === 0) {
            entries.InsufficientDataActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `InsufficientDataActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.MetricName != null) {
        entries["MetricName"] = input.MetricName;
    }
    if (input.Namespace != null) {
        entries["Namespace"] = input.Namespace;
    }
    if (input.Statistic != null) {
        entries["Statistic"] = input.Statistic;
    }
    if (input.ExtendedStatistic != null) {
        entries["ExtendedStatistic"] = input.ExtendedStatistic;
    }
    if (input.Dimensions != null) {
        const memberEntries = se_Dimensions(input.Dimensions, context);
        if (input.Dimensions?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Period != null) {
        entries["Period"] = input.Period;
    }
    if (input.Unit != null) {
        entries["Unit"] = input.Unit;
    }
    if (input.EvaluationPeriods != null) {
        entries["EvaluationPeriods"] = input.EvaluationPeriods;
    }
    if (input.DatapointsToAlarm != null) {
        entries["DatapointsToAlarm"] = input.DatapointsToAlarm;
    }
    if (input.Threshold != null) {
        entries["Threshold"] = __serializeFloat(input.Threshold);
    }
    if (input.ComparisonOperator != null) {
        entries["ComparisonOperator"] = input.ComparisonOperator;
    }
    if (input.TreatMissingData != null) {
        entries["TreatMissingData"] = input.TreatMissingData;
    }
    if (input.EvaluateLowSampleCountPercentile != null) {
        entries["EvaluateLowSampleCountPercentile"] = input.EvaluateLowSampleCountPercentile;
    }
    if (input.Metrics != null) {
        const memberEntries = se_MetricDataQueries(input.Metrics, context);
        if (input.Metrics?.length === 0) {
            entries.Metrics = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Metrics.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Tags != null) {
        const memberEntries = se_TagList(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ThresholdMetricId != null) {
        entries["ThresholdMetricId"] = input.ThresholdMetricId;
    }
    return entries;
};
const se_PutMetricDataInput = (input, context) => {
    const entries = {};
    if (input.Namespace != null) {
        entries["Namespace"] = input.Namespace;
    }
    if (input.MetricData != null) {
        const memberEntries = se_MetricData(input.MetricData, context);
        if (input.MetricData?.length === 0) {
            entries.MetricData = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `MetricData.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PutMetricStreamInput = (input, context) => {
    const entries = {};
    if (input.Name != null) {
        entries["Name"] = input.Name;
    }
    if (input.IncludeFilters != null) {
        const memberEntries = se_MetricStreamFilters(input.IncludeFilters, context);
        if (input.IncludeFilters?.length === 0) {
            entries.IncludeFilters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IncludeFilters.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ExcludeFilters != null) {
        const memberEntries = se_MetricStreamFilters(input.ExcludeFilters, context);
        if (input.ExcludeFilters?.length === 0) {
            entries.ExcludeFilters = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExcludeFilters.${key}`;
            entries[loc] = value;
        });
    }
    if (input.FirehoseArn != null) {
        entries["FirehoseArn"] = input.FirehoseArn;
    }
    if (input.RoleArn != null) {
        entries["RoleArn"] = input.RoleArn;
    }
    if (input.OutputFormat != null) {
        entries["OutputFormat"] = input.OutputFormat;
    }
    if (input.Tags != null) {
        const memberEntries = se_TagList(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input.StatisticsConfigurations != null) {
        const memberEntries = se_MetricStreamStatisticsConfigurations(input.StatisticsConfigurations, context);
        if (input.StatisticsConfigurations?.length === 0) {
            entries.StatisticsConfigurations = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `StatisticsConfigurations.${key}`;
            entries[loc] = value;
        });
    }
    if (input.IncludeLinkedAccountsMetrics != null) {
        entries["IncludeLinkedAccountsMetrics"] = input.IncludeLinkedAccountsMetrics;
    }
    return entries;
};
const se_Range = (input, context) => {
    const entries = {};
    if (input.StartTime != null) {
        entries["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
    }
    if (input.EndTime != null) {
        entries["EndTime"] = input.EndTime.toISOString().split(".")[0] + "Z";
    }
    return entries;
};
const se_ResourceList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SetAlarmStateInput = (input, context) => {
    const entries = {};
    if (input.AlarmName != null) {
        entries["AlarmName"] = input.AlarmName;
    }
    if (input.StateValue != null) {
        entries["StateValue"] = input.StateValue;
    }
    if (input.StateReason != null) {
        entries["StateReason"] = input.StateReason;
    }
    if (input.StateReasonData != null) {
        entries["StateReasonData"] = input.StateReasonData;
    }
    return entries;
};
const se_SingleMetricAnomalyDetector = (input, context) => {
    const entries = {};
    if (input.Namespace != null) {
        entries["Namespace"] = input.Namespace;
    }
    if (input.MetricName != null) {
        entries["MetricName"] = input.MetricName;
    }
    if (input.Dimensions != null) {
        const memberEntries = se_Dimensions(input.Dimensions, context);
        if (input.Dimensions?.length === 0) {
            entries.Dimensions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Dimensions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Stat != null) {
        entries["Stat"] = input.Stat;
    }
    return entries;
};
const se_StartMetricStreamsInput = (input, context) => {
    const entries = {};
    if (input.Names != null) {
        const memberEntries = se_MetricStreamNames(input.Names, context);
        if (input.Names?.length === 0) {
            entries.Names = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Names.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_Statistics = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_StatisticSet = (input, context) => {
    const entries = {};
    if (input.SampleCount != null) {
        entries["SampleCount"] = __serializeFloat(input.SampleCount);
    }
    if (input.Sum != null) {
        entries["Sum"] = __serializeFloat(input.Sum);
    }
    if (input.Minimum != null) {
        entries["Minimum"] = __serializeFloat(input.Minimum);
    }
    if (input.Maximum != null) {
        entries["Maximum"] = __serializeFloat(input.Maximum);
    }
    return entries;
};
const se_StopMetricStreamsInput = (input, context) => {
    const entries = {};
    if (input.Names != null) {
        const memberEntries = se_MetricStreamNames(input.Names, context);
        if (input.Names?.length === 0) {
            entries.Names = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Names.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_Tag = (input, context) => {
    const entries = {};
    if (input.Key != null) {
        entries["Key"] = input.Key;
    }
    if (input.Value != null) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const se_TagKeyList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TagList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TagResourceInput = (input, context) => {
    const entries = {};
    if (input.ResourceARN != null) {
        entries["ResourceARN"] = input.ResourceARN;
    }
    if (input.Tags != null) {
        const memberEntries = se_TagList(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagResourceInput = (input, context) => {
    const entries = {};
    if (input.ResourceARN != null) {
        entries["ResourceARN"] = input.ResourceARN;
    }
    if (input.TagKeys != null) {
        const memberEntries = se_TagKeyList(input.TagKeys, context);
        if (input.TagKeys?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_Values = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = __serializeFloat(entry);
        counter++;
    }
    return entries;
};
const de_AlarmHistoryItem = (output, context) => {
    const contents = {};
    if (output["AlarmName"] !== undefined) {
        contents.AlarmName = __expectString(output["AlarmName"]);
    }
    if (output["AlarmType"] !== undefined) {
        contents.AlarmType = __expectString(output["AlarmType"]);
    }
    if (output["Timestamp"] !== undefined) {
        contents.Timestamp = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["Timestamp"]));
    }
    if (output["HistoryItemType"] !== undefined) {
        contents.HistoryItemType = __expectString(output["HistoryItemType"]);
    }
    if (output["HistorySummary"] !== undefined) {
        contents.HistorySummary = __expectString(output["HistorySummary"]);
    }
    if (output["HistoryData"] !== undefined) {
        contents.HistoryData = __expectString(output["HistoryData"]);
    }
    return contents;
};
const de_AlarmHistoryItems = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AlarmHistoryItem(entry, context);
    });
};
const de_AnomalyDetector = (output, context) => {
    const contents = {};
    if (output["Namespace"] !== undefined) {
        contents.Namespace = __expectString(output["Namespace"]);
    }
    if (output["MetricName"] !== undefined) {
        contents.MetricName = __expectString(output["MetricName"]);
    }
    if (output.Dimensions === "") {
        contents.Dimensions = [];
    }
    else if (output["Dimensions"] !== undefined && output["Dimensions"]["member"] !== undefined) {
        contents.Dimensions = de_Dimensions(__getArrayIfSingleItem(output["Dimensions"]["member"]), context);
    }
    if (output["Stat"] !== undefined) {
        contents.Stat = __expectString(output["Stat"]);
    }
    if (output["Configuration"] !== undefined) {
        contents.Configuration = de_AnomalyDetectorConfiguration(output["Configuration"], context);
    }
    if (output["StateValue"] !== undefined) {
        contents.StateValue = __expectString(output["StateValue"]);
    }
    if (output["SingleMetricAnomalyDetector"] !== undefined) {
        contents.SingleMetricAnomalyDetector = de_SingleMetricAnomalyDetector(output["SingleMetricAnomalyDetector"], context);
    }
    if (output["MetricMathAnomalyDetector"] !== undefined) {
        contents.MetricMathAnomalyDetector = de_MetricMathAnomalyDetector(output["MetricMathAnomalyDetector"], context);
    }
    return contents;
};
const de_AnomalyDetectorConfiguration = (output, context) => {
    const contents = {};
    if (output.ExcludedTimeRanges === "") {
        contents.ExcludedTimeRanges = [];
    }
    else if (output["ExcludedTimeRanges"] !== undefined && output["ExcludedTimeRanges"]["member"] !== undefined) {
        contents.ExcludedTimeRanges = de_AnomalyDetectorExcludedTimeRanges(__getArrayIfSingleItem(output["ExcludedTimeRanges"]["member"]), context);
    }
    if (output["MetricTimezone"] !== undefined) {
        contents.MetricTimezone = __expectString(output["MetricTimezone"]);
    }
    return contents;
};
const de_AnomalyDetectorExcludedTimeRanges = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Range(entry, context);
    });
};
const de_AnomalyDetectors = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AnomalyDetector(entry, context);
    });
};
const de_BatchFailures = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PartialFailure(entry, context);
    });
};
const de_CompositeAlarm = (output, context) => {
    const contents = {};
    if (output["ActionsEnabled"] !== undefined) {
        contents.ActionsEnabled = __parseBoolean(output["ActionsEnabled"]);
    }
    if (output.AlarmActions === "") {
        contents.AlarmActions = [];
    }
    else if (output["AlarmActions"] !== undefined && output["AlarmActions"]["member"] !== undefined) {
        contents.AlarmActions = de_ResourceList(__getArrayIfSingleItem(output["AlarmActions"]["member"]), context);
    }
    if (output["AlarmArn"] !== undefined) {
        contents.AlarmArn = __expectString(output["AlarmArn"]);
    }
    if (output["AlarmConfigurationUpdatedTimestamp"] !== undefined) {
        contents.AlarmConfigurationUpdatedTimestamp = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["AlarmConfigurationUpdatedTimestamp"]));
    }
    if (output["AlarmDescription"] !== undefined) {
        contents.AlarmDescription = __expectString(output["AlarmDescription"]);
    }
    if (output["AlarmName"] !== undefined) {
        contents.AlarmName = __expectString(output["AlarmName"]);
    }
    if (output["AlarmRule"] !== undefined) {
        contents.AlarmRule = __expectString(output["AlarmRule"]);
    }
    if (output.InsufficientDataActions === "") {
        contents.InsufficientDataActions = [];
    }
    else if (output["InsufficientDataActions"] !== undefined &&
        output["InsufficientDataActions"]["member"] !== undefined) {
        contents.InsufficientDataActions = de_ResourceList(__getArrayIfSingleItem(output["InsufficientDataActions"]["member"]), context);
    }
    if (output.OKActions === "") {
        contents.OKActions = [];
    }
    else if (output["OKActions"] !== undefined && output["OKActions"]["member"] !== undefined) {
        contents.OKActions = de_ResourceList(__getArrayIfSingleItem(output["OKActions"]["member"]), context);
    }
    if (output["StateReason"] !== undefined) {
        contents.StateReason = __expectString(output["StateReason"]);
    }
    if (output["StateReasonData"] !== undefined) {
        contents.StateReasonData = __expectString(output["StateReasonData"]);
    }
    if (output["StateUpdatedTimestamp"] !== undefined) {
        contents.StateUpdatedTimestamp = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["StateUpdatedTimestamp"]));
    }
    if (output["StateValue"] !== undefined) {
        contents.StateValue = __expectString(output["StateValue"]);
    }
    if (output["StateTransitionedTimestamp"] !== undefined) {
        contents.StateTransitionedTimestamp = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["StateTransitionedTimestamp"]));
    }
    if (output["ActionsSuppressedBy"] !== undefined) {
        contents.ActionsSuppressedBy = __expectString(output["ActionsSuppressedBy"]);
    }
    if (output["ActionsSuppressedReason"] !== undefined) {
        contents.ActionsSuppressedReason = __expectString(output["ActionsSuppressedReason"]);
    }
    if (output["ActionsSuppressor"] !== undefined) {
        contents.ActionsSuppressor = __expectString(output["ActionsSuppressor"]);
    }
    if (output["ActionsSuppressorWaitPeriod"] !== undefined) {
        contents.ActionsSuppressorWaitPeriod = __strictParseInt32(output["ActionsSuppressorWaitPeriod"]);
    }
    if (output["ActionsSuppressorExtensionPeriod"] !== undefined) {
        contents.ActionsSuppressorExtensionPeriod = __strictParseInt32(output["ActionsSuppressorExtensionPeriod"]);
    }
    return contents;
};
const de_CompositeAlarms = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CompositeAlarm(entry, context);
    });
};
const de_ConcurrentModificationException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = __expectString(output["Message"]);
    }
    return contents;
};
const de_DashboardEntries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DashboardEntry(entry, context);
    });
};
const de_DashboardEntry = (output, context) => {
    const contents = {};
    if (output["DashboardName"] !== undefined) {
        contents.DashboardName = __expectString(output["DashboardName"]);
    }
    if (output["DashboardArn"] !== undefined) {
        contents.DashboardArn = __expectString(output["DashboardArn"]);
    }
    if (output["LastModified"] !== undefined) {
        contents.LastModified = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["LastModified"]));
    }
    if (output["Size"] !== undefined) {
        contents.Size = __strictParseLong(output["Size"]);
    }
    return contents;
};
const de_DashboardInvalidInputError = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    if (output.dashboardValidationMessages === "") {
        contents.dashboardValidationMessages = [];
    }
    else if (output["dashboardValidationMessages"] !== undefined &&
        output["dashboardValidationMessages"]["member"] !== undefined) {
        contents.dashboardValidationMessages = de_DashboardValidationMessages(__getArrayIfSingleItem(output["dashboardValidationMessages"]["member"]), context);
    }
    return contents;
};
const de_DashboardNotFoundError = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_DashboardValidationMessage = (output, context) => {
    const contents = {};
    if (output["DataPath"] !== undefined) {
        contents.DataPath = __expectString(output["DataPath"]);
    }
    if (output["Message"] !== undefined) {
        contents.Message = __expectString(output["Message"]);
    }
    return contents;
};
const de_DashboardValidationMessages = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DashboardValidationMessage(entry, context);
    });
};
const de_Datapoint = (output, context) => {
    const contents = {};
    if (output["Timestamp"] !== undefined) {
        contents.Timestamp = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["Timestamp"]));
    }
    if (output["SampleCount"] !== undefined) {
        contents.SampleCount = __strictParseFloat(output["SampleCount"]);
    }
    if (output["Average"] !== undefined) {
        contents.Average = __strictParseFloat(output["Average"]);
    }
    if (output["Sum"] !== undefined) {
        contents.Sum = __strictParseFloat(output["Sum"]);
    }
    if (output["Minimum"] !== undefined) {
        contents.Minimum = __strictParseFloat(output["Minimum"]);
    }
    if (output["Maximum"] !== undefined) {
        contents.Maximum = __strictParseFloat(output["Maximum"]);
    }
    if (output["Unit"] !== undefined) {
        contents.Unit = __expectString(output["Unit"]);
    }
    if (output.ExtendedStatistics === "") {
        contents.ExtendedStatistics = {};
    }
    else if (output["ExtendedStatistics"] !== undefined && output["ExtendedStatistics"]["entry"] !== undefined) {
        contents.ExtendedStatistics = de_DatapointValueMap(__getArrayIfSingleItem(output["ExtendedStatistics"]["entry"]), context);
    }
    return contents;
};
const de_Datapoints = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Datapoint(entry, context);
    });
};
const de_DatapointValueMap = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = __strictParseFloat(pair["value"]);
        return acc;
    }, {});
};
const de_DatapointValues = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __strictParseFloat(entry);
    });
};
const de_DeleteAnomalyDetectorOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeleteDashboardsOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeleteInsightRulesOutput = (output, context) => {
    const contents = {};
    if (output.Failures === "") {
        contents.Failures = [];
    }
    else if (output["Failures"] !== undefined && output["Failures"]["member"] !== undefined) {
        contents.Failures = de_BatchFailures(__getArrayIfSingleItem(output["Failures"]["member"]), context);
    }
    return contents;
};
const de_DeleteMetricStreamOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DescribeAlarmHistoryOutput = (output, context) => {
    const contents = {};
    if (output.AlarmHistoryItems === "") {
        contents.AlarmHistoryItems = [];
    }
    else if (output["AlarmHistoryItems"] !== undefined && output["AlarmHistoryItems"]["member"] !== undefined) {
        contents.AlarmHistoryItems = de_AlarmHistoryItems(__getArrayIfSingleItem(output["AlarmHistoryItems"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    return contents;
};
const de_DescribeAlarmsForMetricOutput = (output, context) => {
    const contents = {};
    if (output.MetricAlarms === "") {
        contents.MetricAlarms = [];
    }
    else if (output["MetricAlarms"] !== undefined && output["MetricAlarms"]["member"] !== undefined) {
        contents.MetricAlarms = de_MetricAlarms(__getArrayIfSingleItem(output["MetricAlarms"]["member"]), context);
    }
    return contents;
};
const de_DescribeAlarmsOutput = (output, context) => {
    const contents = {};
    if (output.CompositeAlarms === "") {
        contents.CompositeAlarms = [];
    }
    else if (output["CompositeAlarms"] !== undefined && output["CompositeAlarms"]["member"] !== undefined) {
        contents.CompositeAlarms = de_CompositeAlarms(__getArrayIfSingleItem(output["CompositeAlarms"]["member"]), context);
    }
    if (output.MetricAlarms === "") {
        contents.MetricAlarms = [];
    }
    else if (output["MetricAlarms"] !== undefined && output["MetricAlarms"]["member"] !== undefined) {
        contents.MetricAlarms = de_MetricAlarms(__getArrayIfSingleItem(output["MetricAlarms"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    return contents;
};
const de_DescribeAnomalyDetectorsOutput = (output, context) => {
    const contents = {};
    if (output.AnomalyDetectors === "") {
        contents.AnomalyDetectors = [];
    }
    else if (output["AnomalyDetectors"] !== undefined && output["AnomalyDetectors"]["member"] !== undefined) {
        contents.AnomalyDetectors = de_AnomalyDetectors(__getArrayIfSingleItem(output["AnomalyDetectors"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    return contents;
};
const de_DescribeInsightRulesOutput = (output, context) => {
    const contents = {};
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    if (output.InsightRules === "") {
        contents.InsightRules = [];
    }
    else if (output["InsightRules"] !== undefined && output["InsightRules"]["member"] !== undefined) {
        contents.InsightRules = de_InsightRules(__getArrayIfSingleItem(output["InsightRules"]["member"]), context);
    }
    return contents;
};
const de_Dimension = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = __expectString(output["Value"]);
    }
    return contents;
};
const de_Dimensions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Dimension(entry, context);
    });
};
const de_DisableInsightRulesOutput = (output, context) => {
    const contents = {};
    if (output.Failures === "") {
        contents.Failures = [];
    }
    else if (output["Failures"] !== undefined && output["Failures"]["member"] !== undefined) {
        contents.Failures = de_BatchFailures(__getArrayIfSingleItem(output["Failures"]["member"]), context);
    }
    return contents;
};
const de_EnableInsightRulesOutput = (output, context) => {
    const contents = {};
    if (output.Failures === "") {
        contents.Failures = [];
    }
    else if (output["Failures"] !== undefined && output["Failures"]["member"] !== undefined) {
        contents.Failures = de_BatchFailures(__getArrayIfSingleItem(output["Failures"]["member"]), context);
    }
    return contents;
};
const de_GetDashboardOutput = (output, context) => {
    const contents = {};
    if (output["DashboardArn"] !== undefined) {
        contents.DashboardArn = __expectString(output["DashboardArn"]);
    }
    if (output["DashboardBody"] !== undefined) {
        contents.DashboardBody = __expectString(output["DashboardBody"]);
    }
    if (output["DashboardName"] !== undefined) {
        contents.DashboardName = __expectString(output["DashboardName"]);
    }
    return contents;
};
const de_GetInsightRuleReportOutput = (output, context) => {
    const contents = {};
    if (output.KeyLabels === "") {
        contents.KeyLabels = [];
    }
    else if (output["KeyLabels"] !== undefined && output["KeyLabels"]["member"] !== undefined) {
        contents.KeyLabels = de_InsightRuleContributorKeyLabels(__getArrayIfSingleItem(output["KeyLabels"]["member"]), context);
    }
    if (output["AggregationStatistic"] !== undefined) {
        contents.AggregationStatistic = __expectString(output["AggregationStatistic"]);
    }
    if (output["AggregateValue"] !== undefined) {
        contents.AggregateValue = __strictParseFloat(output["AggregateValue"]);
    }
    if (output["ApproximateUniqueCount"] !== undefined) {
        contents.ApproximateUniqueCount = __strictParseLong(output["ApproximateUniqueCount"]);
    }
    if (output.Contributors === "") {
        contents.Contributors = [];
    }
    else if (output["Contributors"] !== undefined && output["Contributors"]["member"] !== undefined) {
        contents.Contributors = de_InsightRuleContributors(__getArrayIfSingleItem(output["Contributors"]["member"]), context);
    }
    if (output.MetricDatapoints === "") {
        contents.MetricDatapoints = [];
    }
    else if (output["MetricDatapoints"] !== undefined && output["MetricDatapoints"]["member"] !== undefined) {
        contents.MetricDatapoints = de_InsightRuleMetricDatapoints(__getArrayIfSingleItem(output["MetricDatapoints"]["member"]), context);
    }
    return contents;
};
const de_GetMetricDataOutput = (output, context) => {
    const contents = {};
    if (output.MetricDataResults === "") {
        contents.MetricDataResults = [];
    }
    else if (output["MetricDataResults"] !== undefined && output["MetricDataResults"]["member"] !== undefined) {
        contents.MetricDataResults = de_MetricDataResults(__getArrayIfSingleItem(output["MetricDataResults"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    if (output.Messages === "") {
        contents.Messages = [];
    }
    else if (output["Messages"] !== undefined && output["Messages"]["member"] !== undefined) {
        contents.Messages = de_MetricDataResultMessages(__getArrayIfSingleItem(output["Messages"]["member"]), context);
    }
    return contents;
};
const de_GetMetricStatisticsOutput = (output, context) => {
    const contents = {};
    if (output["Label"] !== undefined) {
        contents.Label = __expectString(output["Label"]);
    }
    if (output.Datapoints === "") {
        contents.Datapoints = [];
    }
    else if (output["Datapoints"] !== undefined && output["Datapoints"]["member"] !== undefined) {
        contents.Datapoints = de_Datapoints(__getArrayIfSingleItem(output["Datapoints"]["member"]), context);
    }
    return contents;
};
const de_GetMetricStreamOutput = (output, context) => {
    const contents = {};
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output.IncludeFilters === "") {
        contents.IncludeFilters = [];
    }
    else if (output["IncludeFilters"] !== undefined && output["IncludeFilters"]["member"] !== undefined) {
        contents.IncludeFilters = de_MetricStreamFilters(__getArrayIfSingleItem(output["IncludeFilters"]["member"]), context);
    }
    if (output.ExcludeFilters === "") {
        contents.ExcludeFilters = [];
    }
    else if (output["ExcludeFilters"] !== undefined && output["ExcludeFilters"]["member"] !== undefined) {
        contents.ExcludeFilters = de_MetricStreamFilters(__getArrayIfSingleItem(output["ExcludeFilters"]["member"]), context);
    }
    if (output["FirehoseArn"] !== undefined) {
        contents.FirehoseArn = __expectString(output["FirehoseArn"]);
    }
    if (output["RoleArn"] !== undefined) {
        contents.RoleArn = __expectString(output["RoleArn"]);
    }
    if (output["State"] !== undefined) {
        contents.State = __expectString(output["State"]);
    }
    if (output["CreationDate"] !== undefined) {
        contents.CreationDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreationDate"]));
    }
    if (output["LastUpdateDate"] !== undefined) {
        contents.LastUpdateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["LastUpdateDate"]));
    }
    if (output["OutputFormat"] !== undefined) {
        contents.OutputFormat = __expectString(output["OutputFormat"]);
    }
    if (output.StatisticsConfigurations === "") {
        contents.StatisticsConfigurations = [];
    }
    else if (output["StatisticsConfigurations"] !== undefined &&
        output["StatisticsConfigurations"]["member"] !== undefined) {
        contents.StatisticsConfigurations = de_MetricStreamStatisticsConfigurations(__getArrayIfSingleItem(output["StatisticsConfigurations"]["member"]), context);
    }
    if (output["IncludeLinkedAccountsMetrics"] !== undefined) {
        contents.IncludeLinkedAccountsMetrics = __parseBoolean(output["IncludeLinkedAccountsMetrics"]);
    }
    return contents;
};
const de_GetMetricWidgetImageOutput = (output, context) => {
    const contents = {};
    if (output["MetricWidgetImage"] !== undefined) {
        contents.MetricWidgetImage = context.base64Decoder(output["MetricWidgetImage"]);
    }
    return contents;
};
const de_InsightRule = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["State"] !== undefined) {
        contents.State = __expectString(output["State"]);
    }
    if (output["Schema"] !== undefined) {
        contents.Schema = __expectString(output["Schema"]);
    }
    if (output["Definition"] !== undefined) {
        contents.Definition = __expectString(output["Definition"]);
    }
    if (output["ManagedRule"] !== undefined) {
        contents.ManagedRule = __parseBoolean(output["ManagedRule"]);
    }
    return contents;
};
const de_InsightRuleContributor = (output, context) => {
    const contents = {};
    if (output.Keys === "") {
        contents.Keys = [];
    }
    else if (output["Keys"] !== undefined && output["Keys"]["member"] !== undefined) {
        contents.Keys = de_InsightRuleContributorKeys(__getArrayIfSingleItem(output["Keys"]["member"]), context);
    }
    if (output["ApproximateAggregateValue"] !== undefined) {
        contents.ApproximateAggregateValue = __strictParseFloat(output["ApproximateAggregateValue"]);
    }
    if (output.Datapoints === "") {
        contents.Datapoints = [];
    }
    else if (output["Datapoints"] !== undefined && output["Datapoints"]["member"] !== undefined) {
        contents.Datapoints = de_InsightRuleContributorDatapoints(__getArrayIfSingleItem(output["Datapoints"]["member"]), context);
    }
    return contents;
};
const de_InsightRuleContributorDatapoint = (output, context) => {
    const contents = {};
    if (output["Timestamp"] !== undefined) {
        contents.Timestamp = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["Timestamp"]));
    }
    if (output["ApproximateValue"] !== undefined) {
        contents.ApproximateValue = __strictParseFloat(output["ApproximateValue"]);
    }
    return contents;
};
const de_InsightRuleContributorDatapoints = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InsightRuleContributorDatapoint(entry, context);
    });
};
const de_InsightRuleContributorKeyLabels = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_InsightRuleContributorKeys = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_InsightRuleContributors = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InsightRuleContributor(entry, context);
    });
};
const de_InsightRuleMetricDatapoint = (output, context) => {
    const contents = {};
    if (output["Timestamp"] !== undefined) {
        contents.Timestamp = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["Timestamp"]));
    }
    if (output["UniqueContributors"] !== undefined) {
        contents.UniqueContributors = __strictParseFloat(output["UniqueContributors"]);
    }
    if (output["MaxContributorValue"] !== undefined) {
        contents.MaxContributorValue = __strictParseFloat(output["MaxContributorValue"]);
    }
    if (output["SampleCount"] !== undefined) {
        contents.SampleCount = __strictParseFloat(output["SampleCount"]);
    }
    if (output["Average"] !== undefined) {
        contents.Average = __strictParseFloat(output["Average"]);
    }
    if (output["Sum"] !== undefined) {
        contents.Sum = __strictParseFloat(output["Sum"]);
    }
    if (output["Minimum"] !== undefined) {
        contents.Minimum = __strictParseFloat(output["Minimum"]);
    }
    if (output["Maximum"] !== undefined) {
        contents.Maximum = __strictParseFloat(output["Maximum"]);
    }
    return contents;
};
const de_InsightRuleMetricDatapoints = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InsightRuleMetricDatapoint(entry, context);
    });
};
const de_InsightRules = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InsightRule(entry, context);
    });
};
const de_InternalServiceFault = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = __expectString(output["Message"]);
    }
    return contents;
};
const de_InvalidFormatFault = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_InvalidNextToken = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_InvalidParameterCombinationException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_InvalidParameterValueException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_LimitExceededException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = __expectString(output["Message"]);
    }
    return contents;
};
const de_LimitExceededFault = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_ListDashboardsOutput = (output, context) => {
    const contents = {};
    if (output.DashboardEntries === "") {
        contents.DashboardEntries = [];
    }
    else if (output["DashboardEntries"] !== undefined && output["DashboardEntries"]["member"] !== undefined) {
        contents.DashboardEntries = de_DashboardEntries(__getArrayIfSingleItem(output["DashboardEntries"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    return contents;
};
const de_ListManagedInsightRulesOutput = (output, context) => {
    const contents = {};
    if (output.ManagedRules === "") {
        contents.ManagedRules = [];
    }
    else if (output["ManagedRules"] !== undefined && output["ManagedRules"]["member"] !== undefined) {
        contents.ManagedRules = de_ManagedRuleDescriptions(__getArrayIfSingleItem(output["ManagedRules"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    return contents;
};
const de_ListMetricsOutput = (output, context) => {
    const contents = {};
    if (output.Metrics === "") {
        contents.Metrics = [];
    }
    else if (output["Metrics"] !== undefined && output["Metrics"]["member"] !== undefined) {
        contents.Metrics = de_Metrics(__getArrayIfSingleItem(output["Metrics"]["member"]), context);
    }
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    if (output.OwningAccounts === "") {
        contents.OwningAccounts = [];
    }
    else if (output["OwningAccounts"] !== undefined && output["OwningAccounts"]["member"] !== undefined) {
        contents.OwningAccounts = de_OwningAccounts(__getArrayIfSingleItem(output["OwningAccounts"]["member"]), context);
    }
    return contents;
};
const de_ListMetricStreamsOutput = (output, context) => {
    const contents = {};
    if (output["NextToken"] !== undefined) {
        contents.NextToken = __expectString(output["NextToken"]);
    }
    if (output.Entries === "") {
        contents.Entries = [];
    }
    else if (output["Entries"] !== undefined && output["Entries"]["member"] !== undefined) {
        contents.Entries = de_MetricStreamEntries(__getArrayIfSingleItem(output["Entries"]["member"]), context);
    }
    return contents;
};
const de_ListTagsForResourceOutput = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_TagList(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_ManagedRuleDescription = (output, context) => {
    const contents = {};
    if (output["TemplateName"] !== undefined) {
        contents.TemplateName = __expectString(output["TemplateName"]);
    }
    if (output["ResourceARN"] !== undefined) {
        contents.ResourceARN = __expectString(output["ResourceARN"]);
    }
    if (output["RuleState"] !== undefined) {
        contents.RuleState = de_ManagedRuleState(output["RuleState"], context);
    }
    return contents;
};
const de_ManagedRuleDescriptions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ManagedRuleDescription(entry, context);
    });
};
const de_ManagedRuleState = (output, context) => {
    const contents = {};
    if (output["RuleName"] !== undefined) {
        contents.RuleName = __expectString(output["RuleName"]);
    }
    if (output["State"] !== undefined) {
        contents.State = __expectString(output["State"]);
    }
    return contents;
};
const de_MessageData = (output, context) => {
    const contents = {};
    if (output["Code"] !== undefined) {
        contents.Code = __expectString(output["Code"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = __expectString(output["Value"]);
    }
    return contents;
};
const de_Metric = (output, context) => {
    const contents = {};
    if (output["Namespace"] !== undefined) {
        contents.Namespace = __expectString(output["Namespace"]);
    }
    if (output["MetricName"] !== undefined) {
        contents.MetricName = __expectString(output["MetricName"]);
    }
    if (output.Dimensions === "") {
        contents.Dimensions = [];
    }
    else if (output["Dimensions"] !== undefined && output["Dimensions"]["member"] !== undefined) {
        contents.Dimensions = de_Dimensions(__getArrayIfSingleItem(output["Dimensions"]["member"]), context);
    }
    return contents;
};
const de_MetricAlarm = (output, context) => {
    const contents = {};
    if (output["AlarmName"] !== undefined) {
        contents.AlarmName = __expectString(output["AlarmName"]);
    }
    if (output["AlarmArn"] !== undefined) {
        contents.AlarmArn = __expectString(output["AlarmArn"]);
    }
    if (output["AlarmDescription"] !== undefined) {
        contents.AlarmDescription = __expectString(output["AlarmDescription"]);
    }
    if (output["AlarmConfigurationUpdatedTimestamp"] !== undefined) {
        contents.AlarmConfigurationUpdatedTimestamp = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["AlarmConfigurationUpdatedTimestamp"]));
    }
    if (output["ActionsEnabled"] !== undefined) {
        contents.ActionsEnabled = __parseBoolean(output["ActionsEnabled"]);
    }
    if (output.OKActions === "") {
        contents.OKActions = [];
    }
    else if (output["OKActions"] !== undefined && output["OKActions"]["member"] !== undefined) {
        contents.OKActions = de_ResourceList(__getArrayIfSingleItem(output["OKActions"]["member"]), context);
    }
    if (output.AlarmActions === "") {
        contents.AlarmActions = [];
    }
    else if (output["AlarmActions"] !== undefined && output["AlarmActions"]["member"] !== undefined) {
        contents.AlarmActions = de_ResourceList(__getArrayIfSingleItem(output["AlarmActions"]["member"]), context);
    }
    if (output.InsufficientDataActions === "") {
        contents.InsufficientDataActions = [];
    }
    else if (output["InsufficientDataActions"] !== undefined &&
        output["InsufficientDataActions"]["member"] !== undefined) {
        contents.InsufficientDataActions = de_ResourceList(__getArrayIfSingleItem(output["InsufficientDataActions"]["member"]), context);
    }
    if (output["StateValue"] !== undefined) {
        contents.StateValue = __expectString(output["StateValue"]);
    }
    if (output["StateReason"] !== undefined) {
        contents.StateReason = __expectString(output["StateReason"]);
    }
    if (output["StateReasonData"] !== undefined) {
        contents.StateReasonData = __expectString(output["StateReasonData"]);
    }
    if (output["StateUpdatedTimestamp"] !== undefined) {
        contents.StateUpdatedTimestamp = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["StateUpdatedTimestamp"]));
    }
    if (output["MetricName"] !== undefined) {
        contents.MetricName = __expectString(output["MetricName"]);
    }
    if (output["Namespace"] !== undefined) {
        contents.Namespace = __expectString(output["Namespace"]);
    }
    if (output["Statistic"] !== undefined) {
        contents.Statistic = __expectString(output["Statistic"]);
    }
    if (output["ExtendedStatistic"] !== undefined) {
        contents.ExtendedStatistic = __expectString(output["ExtendedStatistic"]);
    }
    if (output.Dimensions === "") {
        contents.Dimensions = [];
    }
    else if (output["Dimensions"] !== undefined && output["Dimensions"]["member"] !== undefined) {
        contents.Dimensions = de_Dimensions(__getArrayIfSingleItem(output["Dimensions"]["member"]), context);
    }
    if (output["Period"] !== undefined) {
        contents.Period = __strictParseInt32(output["Period"]);
    }
    if (output["Unit"] !== undefined) {
        contents.Unit = __expectString(output["Unit"]);
    }
    if (output["EvaluationPeriods"] !== undefined) {
        contents.EvaluationPeriods = __strictParseInt32(output["EvaluationPeriods"]);
    }
    if (output["DatapointsToAlarm"] !== undefined) {
        contents.DatapointsToAlarm = __strictParseInt32(output["DatapointsToAlarm"]);
    }
    if (output["Threshold"] !== undefined) {
        contents.Threshold = __strictParseFloat(output["Threshold"]);
    }
    if (output["ComparisonOperator"] !== undefined) {
        contents.ComparisonOperator = __expectString(output["ComparisonOperator"]);
    }
    if (output["TreatMissingData"] !== undefined) {
        contents.TreatMissingData = __expectString(output["TreatMissingData"]);
    }
    if (output["EvaluateLowSampleCountPercentile"] !== undefined) {
        contents.EvaluateLowSampleCountPercentile = __expectString(output["EvaluateLowSampleCountPercentile"]);
    }
    if (output.Metrics === "") {
        contents.Metrics = [];
    }
    else if (output["Metrics"] !== undefined && output["Metrics"]["member"] !== undefined) {
        contents.Metrics = de_MetricDataQueries(__getArrayIfSingleItem(output["Metrics"]["member"]), context);
    }
    if (output["ThresholdMetricId"] !== undefined) {
        contents.ThresholdMetricId = __expectString(output["ThresholdMetricId"]);
    }
    if (output["EvaluationState"] !== undefined) {
        contents.EvaluationState = __expectString(output["EvaluationState"]);
    }
    if (output["StateTransitionedTimestamp"] !== undefined) {
        contents.StateTransitionedTimestamp = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["StateTransitionedTimestamp"]));
    }
    return contents;
};
const de_MetricAlarms = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricAlarm(entry, context);
    });
};
const de_MetricDataQueries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricDataQuery(entry, context);
    });
};
const de_MetricDataQuery = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
        contents.Id = __expectString(output["Id"]);
    }
    if (output["MetricStat"] !== undefined) {
        contents.MetricStat = de_MetricStat(output["MetricStat"], context);
    }
    if (output["Expression"] !== undefined) {
        contents.Expression = __expectString(output["Expression"]);
    }
    if (output["Label"] !== undefined) {
        contents.Label = __expectString(output["Label"]);
    }
    if (output["ReturnData"] !== undefined) {
        contents.ReturnData = __parseBoolean(output["ReturnData"]);
    }
    if (output["Period"] !== undefined) {
        contents.Period = __strictParseInt32(output["Period"]);
    }
    if (output["AccountId"] !== undefined) {
        contents.AccountId = __expectString(output["AccountId"]);
    }
    return contents;
};
const de_MetricDataResult = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
        contents.Id = __expectString(output["Id"]);
    }
    if (output["Label"] !== undefined) {
        contents.Label = __expectString(output["Label"]);
    }
    if (output.Timestamps === "") {
        contents.Timestamps = [];
    }
    else if (output["Timestamps"] !== undefined && output["Timestamps"]["member"] !== undefined) {
        contents.Timestamps = de_Timestamps(__getArrayIfSingleItem(output["Timestamps"]["member"]), context);
    }
    if (output.Values === "") {
        contents.Values = [];
    }
    else if (output["Values"] !== undefined && output["Values"]["member"] !== undefined) {
        contents.Values = de_DatapointValues(__getArrayIfSingleItem(output["Values"]["member"]), context);
    }
    if (output["StatusCode"] !== undefined) {
        contents.StatusCode = __expectString(output["StatusCode"]);
    }
    if (output.Messages === "") {
        contents.Messages = [];
    }
    else if (output["Messages"] !== undefined && output["Messages"]["member"] !== undefined) {
        contents.Messages = de_MetricDataResultMessages(__getArrayIfSingleItem(output["Messages"]["member"]), context);
    }
    return contents;
};
const de_MetricDataResultMessages = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MessageData(entry, context);
    });
};
const de_MetricDataResults = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricDataResult(entry, context);
    });
};
const de_MetricMathAnomalyDetector = (output, context) => {
    const contents = {};
    if (output.MetricDataQueries === "") {
        contents.MetricDataQueries = [];
    }
    else if (output["MetricDataQueries"] !== undefined && output["MetricDataQueries"]["member"] !== undefined) {
        contents.MetricDataQueries = de_MetricDataQueries(__getArrayIfSingleItem(output["MetricDataQueries"]["member"]), context);
    }
    return contents;
};
const de_Metrics = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Metric(entry, context);
    });
};
const de_MetricStat = (output, context) => {
    const contents = {};
    if (output["Metric"] !== undefined) {
        contents.Metric = de_Metric(output["Metric"], context);
    }
    if (output["Period"] !== undefined) {
        contents.Period = __strictParseInt32(output["Period"]);
    }
    if (output["Stat"] !== undefined) {
        contents.Stat = __expectString(output["Stat"]);
    }
    if (output["Unit"] !== undefined) {
        contents.Unit = __expectString(output["Unit"]);
    }
    return contents;
};
const de_MetricStreamEntries = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricStreamEntry(entry, context);
    });
};
const de_MetricStreamEntry = (output, context) => {
    const contents = {};
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    if (output["CreationDate"] !== undefined) {
        contents.CreationDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreationDate"]));
    }
    if (output["LastUpdateDate"] !== undefined) {
        contents.LastUpdateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["LastUpdateDate"]));
    }
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["FirehoseArn"] !== undefined) {
        contents.FirehoseArn = __expectString(output["FirehoseArn"]);
    }
    if (output["State"] !== undefined) {
        contents.State = __expectString(output["State"]);
    }
    if (output["OutputFormat"] !== undefined) {
        contents.OutputFormat = __expectString(output["OutputFormat"]);
    }
    return contents;
};
const de_MetricStreamFilter = (output, context) => {
    const contents = {};
    if (output["Namespace"] !== undefined) {
        contents.Namespace = __expectString(output["Namespace"]);
    }
    if (output.MetricNames === "") {
        contents.MetricNames = [];
    }
    else if (output["MetricNames"] !== undefined && output["MetricNames"]["member"] !== undefined) {
        contents.MetricNames = de_MetricStreamFilterMetricNames(__getArrayIfSingleItem(output["MetricNames"]["member"]), context);
    }
    return contents;
};
const de_MetricStreamFilterMetricNames = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_MetricStreamFilters = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricStreamFilter(entry, context);
    });
};
const de_MetricStreamStatisticsAdditionalStatistics = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_MetricStreamStatisticsConfiguration = (output, context) => {
    const contents = {};
    if (output.IncludeMetrics === "") {
        contents.IncludeMetrics = [];
    }
    else if (output["IncludeMetrics"] !== undefined && output["IncludeMetrics"]["member"] !== undefined) {
        contents.IncludeMetrics = de_MetricStreamStatisticsIncludeMetrics(__getArrayIfSingleItem(output["IncludeMetrics"]["member"]), context);
    }
    if (output.AdditionalStatistics === "") {
        contents.AdditionalStatistics = [];
    }
    else if (output["AdditionalStatistics"] !== undefined && output["AdditionalStatistics"]["member"] !== undefined) {
        contents.AdditionalStatistics = de_MetricStreamStatisticsAdditionalStatistics(__getArrayIfSingleItem(output["AdditionalStatistics"]["member"]), context);
    }
    return contents;
};
const de_MetricStreamStatisticsConfigurations = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricStreamStatisticsConfiguration(entry, context);
    });
};
const de_MetricStreamStatisticsIncludeMetrics = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricStreamStatisticsMetric(entry, context);
    });
};
const de_MetricStreamStatisticsMetric = (output, context) => {
    const contents = {};
    if (output["Namespace"] !== undefined) {
        contents.Namespace = __expectString(output["Namespace"]);
    }
    if (output["MetricName"] !== undefined) {
        contents.MetricName = __expectString(output["MetricName"]);
    }
    return contents;
};
const de_MissingRequiredParameterException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_OwningAccounts = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_PartialFailure = (output, context) => {
    const contents = {};
    if (output["FailureResource"] !== undefined) {
        contents.FailureResource = __expectString(output["FailureResource"]);
    }
    if (output["ExceptionType"] !== undefined) {
        contents.ExceptionType = __expectString(output["ExceptionType"]);
    }
    if (output["FailureCode"] !== undefined) {
        contents.FailureCode = __expectString(output["FailureCode"]);
    }
    if (output["FailureDescription"] !== undefined) {
        contents.FailureDescription = __expectString(output["FailureDescription"]);
    }
    return contents;
};
const de_PutAnomalyDetectorOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_PutDashboardOutput = (output, context) => {
    const contents = {};
    if (output.DashboardValidationMessages === "") {
        contents.DashboardValidationMessages = [];
    }
    else if (output["DashboardValidationMessages"] !== undefined &&
        output["DashboardValidationMessages"]["member"] !== undefined) {
        contents.DashboardValidationMessages = de_DashboardValidationMessages(__getArrayIfSingleItem(output["DashboardValidationMessages"]["member"]), context);
    }
    return contents;
};
const de_PutInsightRuleOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_PutManagedInsightRulesOutput = (output, context) => {
    const contents = {};
    if (output.Failures === "") {
        contents.Failures = [];
    }
    else if (output["Failures"] !== undefined && output["Failures"]["member"] !== undefined) {
        contents.Failures = de_BatchFailures(__getArrayIfSingleItem(output["Failures"]["member"]), context);
    }
    return contents;
};
const de_PutMetricStreamOutput = (output, context) => {
    const contents = {};
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    return contents;
};
const de_Range = (output, context) => {
    const contents = {};
    if (output["StartTime"] !== undefined) {
        contents.StartTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["StartTime"]));
    }
    if (output["EndTime"] !== undefined) {
        contents.EndTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["EndTime"]));
    }
    return contents;
};
const de_ResourceList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ResourceNotFound = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_ResourceNotFoundException = (output, context) => {
    const contents = {};
    if (output["ResourceType"] !== undefined) {
        contents.ResourceType = __expectString(output["ResourceType"]);
    }
    if (output["ResourceId"] !== undefined) {
        contents.ResourceId = __expectString(output["ResourceId"]);
    }
    if (output["Message"] !== undefined) {
        contents.Message = __expectString(output["Message"]);
    }
    return contents;
};
const de_SingleMetricAnomalyDetector = (output, context) => {
    const contents = {};
    if (output["Namespace"] !== undefined) {
        contents.Namespace = __expectString(output["Namespace"]);
    }
    if (output["MetricName"] !== undefined) {
        contents.MetricName = __expectString(output["MetricName"]);
    }
    if (output.Dimensions === "") {
        contents.Dimensions = [];
    }
    else if (output["Dimensions"] !== undefined && output["Dimensions"]["member"] !== undefined) {
        contents.Dimensions = de_Dimensions(__getArrayIfSingleItem(output["Dimensions"]["member"]), context);
    }
    if (output["Stat"] !== undefined) {
        contents.Stat = __expectString(output["Stat"]);
    }
    return contents;
};
const de_StartMetricStreamsOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_StopMetricStreamsOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_Tag = (output, context) => {
    const contents = {};
    if (output["Key"] !== undefined) {
        contents.Key = __expectString(output["Key"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = __expectString(output["Value"]);
    }
    return contents;
};
const de_TagList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Tag(entry, context);
    });
};
const de_TagResourceOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_Timestamps = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectNonNull(__parseRfc3339DateTimeWithOffset(entry));
    });
};
const de_UntagResourceOutput = (output, context) => {
    const contents = {};
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = withBaseException(__BaseException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded",
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        const parsedObj = parser.parse(encoded);
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return __getValueFromTextNode(parsedObjToReturn);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => __extendedEncodeURIComponent(key) + "=" + __extendedEncodeURIComponent(value))
    .join("&");
const loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};
