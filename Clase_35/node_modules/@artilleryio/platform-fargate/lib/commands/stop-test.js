
module.exports = {
  stopTestCmd,
  stopTest
};

const AWS = require('aws-sdk');

const debug = require('debug')('commands:stop-test');

const { describeTestRun } = require('../data-api/describe-test-run');
const { TestRunObject } = require('../data-api/test-run-object');
const setDefaultAWSCredentials = require('../utils/aws-set-default-credentials');
const getBackendStore = require('../utils/get-backend-store');

async function stopTestCmd(shortTestId) {
  debug('Stopping test', shortTestId);
  await setDefaultAWSCredentials();
  await stopTest(shortTestId, { clean: false, interactive: true });
}

// TODO: Detect when a test does not exist!!

async function stopTest(shortTestId, opts) {
  let testRunObject;
  try {
    testRunObject = await describeTestRun(shortTestId);

    debug(testRunObject);

  } catch (err) {
    debug(err);
    artillery.log('Something went wrong');
    process.exit(1);
  }

  // TODO: May not need to try to stop - check status

  for (const taskArn of testRunObject.tasks) {
    try {
      if(!opts.clean) { // Early stop, ie tasks still running
        const ecs = new AWS.ECS({ apiVersion: '2014-11-13', region: testRunObject.metadata.region });
        await ecs.stopTask({
          task: taskArn,
          cluster: testRunObject.metadata.cluster,
          reason: 'Test cleanup'
        }).promise();
      }
    } catch (err) {
      // TODO: Retry if appropriate, give the user more information
      // to be able to fall back to manual intervention if possible.
      // TODO: Consumer has no idea if this succeeded or not
      debug(err);
    }
  }

  if(opts.interactive) {
    const t = new TestRunObject(shortTestId, await getBackendStore());
    const opts = { testRunId: shortTestId }
    await t.init(shortTestId, opts); // TODO: Refactor. This is a bad API with shortId also being passed into the constructor
    await t.setStatus('EARLY_STOP');
  }

  if (!opts.interactive === false) {
    artillery.log(`Stopped test: ${shortTestId}`);
  }
}
