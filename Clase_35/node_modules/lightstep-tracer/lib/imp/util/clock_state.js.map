{"version":3,"sources":["../../../src/imp/util/clock_state.js"],"names":[],"mappings":"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","file":"clock_state.js","sourcesContent":["import _each from '../../_each';\n\n// How many updates before a sample is considered old. This happens to\n// be one less than the number of samples in our buffer but that's\n// somewhat arbitrary.\nconst kMaxOffsetAge = 7;\n\nconst kStoredSamplesTTLMicros = 60 * 60 * 1000 * 1000; // 1 hour\n\nclass ClockState {\n    constructor(opts) {\n        this._nowMicros     = opts.nowMicros;\n        this._localStoreGet = opts.localStoreGet;\n        this._localStoreSet = opts.localStoreSet;\n\n        // The last eight samples, computed from timing information in\n        // RPCs.\n        this._samples = [];\n        this._currentOffsetMicros = 0;\n\n        // How many updates since we've updated currentOffsetMicros.\n        this._currentOffsetAge = kMaxOffsetAge + 1;\n\n        // Try to load samples from the local store.\n        // Only use the data if it's recent.\n        let storedData = this._localStoreGet();\n        if (storedData\n            && storedData.timestamp_micros\n            && storedData.timestamp_micros > this._nowMicros() - kStoredSamplesTTLMicros) {\n            // Make sure there are no more than (kMaxOffsetAge+1) elements\n            this._samples = storedData.samples.slice(-(kMaxOffsetAge + 1));\n        }\n        // Update the current offset based on these data.\n        this.update();\n    }\n\n    // Add a new timing sample and update the offset.\n    addSample(originMicros,\n        receiveMicros,\n        transmitMicros,\n        destinationMicros) {\n        let latestDelayMicros = Number.MAX_VALUE;\n        let latestOffsetMicros = 0;\n        // Ensure that all of the data are valid before using them. If\n        // not, we'll push a {0, MAX} record into the queue.\n        if (originMicros > 0 && receiveMicros > 0\n            && transmitMicros > 0 && destinationMicros > 0) {\n            latestDelayMicros = (destinationMicros - originMicros)\n                - (transmitMicros - receiveMicros);\n            latestOffsetMicros = ((receiveMicros - originMicros)\n                           + (transmitMicros - destinationMicros)) / 2;\n        }\n\n        // Discard the oldest sample and push the new one.\n        if (this._samples.length === kMaxOffsetAge + 1) {\n            this._samples.shift();\n        }\n        this._samples.push({\n            delayMicros  : latestDelayMicros,\n            offsetMicros : latestOffsetMicros,\n        });\n        this._currentOffsetAge++;\n\n        // Update the local store with this new sample.\n        this._localStoreSet({\n            timestamp_micros : this._nowMicros(),\n            samples          : this._samples,\n        });\n        this.update();\n    }\n\n    // Update the time offset based on the current samples.\n    update() {\n        // This is simplified version of the clock filtering in Simple\n        // NTP. It ignores precision and dispersion (frequency error). In\n        // brief, it keeps the 8 (kMaxOffsetAge+1) most recent\n        // delay-offset pairs, and considers the offset with the smallest\n        // delay to be the best one. However, it only uses this new offset\n        // if the change (relative to the last offset) is small compared\n        // to the estimated error.\n        //\n        // See:\n        // https://tools.ietf.org/html/rfc5905#appendix-A.5.2\n        // http://books.google.com/books?id=pdTcJBfnbq8C\n        //   esp. section 3.5\n        // http://www.eecis.udel.edu/~mills/ntp/html/filter.html\n        // http://www.eecis.udel.edu/~mills/database/brief/algor/algor.pdf\n        // http://www.eecis.udel.edu/~mills/ntp/html/stats.html\n\n        // TODO: Consider huff-n'-puff if the delays are highly asymmetric.\n        // http://www.eecis.udel.edu/~mills/ntp/html/huffpuff.html\n\n        // Find the sample with the smallest delay; the corresponding\n        // offset is the \"best\" one.\n        let minDelayMicros = Number.MAX_VALUE;\n        let bestOffsetMicros = 0;\n        _each(this._samples, (sample) => {\n            if (sample.delayMicros < minDelayMicros) {\n                minDelayMicros = sample.delayMicros;\n                bestOffsetMicros = sample.offsetMicros;\n            }\n        });\n\n        // No update.\n        if (bestOffsetMicros === this._currentOffsetMicros) {\n            return;\n        }\n\n        // Now compute the jitter, i.e. the error relative to the new\n        // offset were we to use it.\n        let jitter = 0;\n        _each(this._samples, (sample) => {\n            // eslint-disable-next-line no-restricted-properties\n            jitter += Math.pow(bestOffsetMicros - sample.offsetMicros, 2);\n        });\n        jitter = Math.sqrt(jitter / this._samples.length);\n\n        // Ignore spikes: only use the new offset if the change is not too\n        // large... unless the current offset is too old. The \"too old\"\n        // condition is also triggered when update() is called from the\n        // constructor.\n        const kSGATE = 3; // See RFC 5905\n        if (this._currentOffsetAge > kMaxOffsetAge\n            || Math.abs(this._currentOffsetMicros - bestOffsetMicros) < kSGATE * jitter) {\n            this._currentOffsetMicros = bestOffsetMicros;\n            this._currentOffsetAge = 0;\n        }\n    }\n\n    // Returns the difference in microseconds between the server's clock\n    // and our clock. This should be added to any local timestamps before\n    // sending them to the server. Note that a negative offset means that\n    // the local clock is ahead of the server's.\n    offsetMicros() {\n        return Math.floor(this._currentOffsetMicros);\n    }\n\n    // Returns true if we've performed enough measurements to be confident\n    // in the current offset.\n    isReady() {\n        return this._samples.length > 3;\n    }\n\n    activeSampleCount() {\n        return this._samples.length;\n    }\n}\n\nmodule.exports = ClockState;\n"]}