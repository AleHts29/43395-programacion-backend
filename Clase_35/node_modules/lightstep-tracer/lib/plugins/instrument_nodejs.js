'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _opentracing = require('opentracing');

var opentracing = _interopRequireWildcard(_opentracing);

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _https = require('https');

var _https2 = _interopRequireDefault(_https);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Capture the proxied values on script load (i.e. ASAP) in case there are
// multiple layers of instrumentation.
var proxiedHttpRequest = void 0;
var proxiedHttpsRequest = void 0;
var proxiedHttpGet = void 0;
var proxiedHttpsGet = void 0;
if (typeof window === 'undefined') {
    proxiedHttpRequest = _http2.default.request;
    proxiedHttpGet = _http2.default.get;

    proxiedHttpsRequest = _https2.default.request;
    proxiedHttpsGet = _https2.default.get;
}

// taken from following
// https://github.com/nodejs/node/blob/8507485fb242dfcaf07092414871aa9c185a28e4/lib/internal/url.js#L1254-L1276
// Utility function that converts a URL object into an ordinary
// options object as expected by the http.request and https.request
// APIs.
function urlToOptions(url) {
    var options = {
        protocol: url.protocol,
        hostname: typeof url.hostname === 'string' && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        path: '' + (url.pathname || '') + (url.search || ''),
        href: url.href
    };
    if (url.port !== '') {
        options.port = Number(url.port);
    }
    if (url.username || url.password) {
        options.auth = url.username + ':' + url.password;
    }
    return options;
}

// Automatically create spans for all requests made via window.fetch.
//
// NOTE: this code currently works only with a single Tracer.
//

var InstrumentNodejs = function () {
    function InstrumentNodejs() {
        _classCallCheck(this, InstrumentNodejs);

        this._enabled = this._isValidContext();
        this._proxyInited = false;
        this._internalExclusions = [];
        this._tracer = null;
        this._handleOptions = this._handleOptions.bind(this);
    }

    _createClass(InstrumentNodejs, [{
        key: 'name',
        value: function name() {
            return 'instrument_nodejs';
        }
    }, {
        key: 'addOptions',
        value: function addOptions(tracerImp) {
            tracerImp.addOption('nodejs_instrumentation', { type: 'bool', defaultValue: false });
            tracerImp.addOption('nodejs_url_inclusion_patterns', { type: 'array', defaultValue: [/.*/] });
            tracerImp.addOption('nodejs_url_exclusion_patterns', { type: 'array', defaultValue: [] });
            tracerImp.addOption('include_cookies', { type: 'bool', defaultValue: true });
        }
    }, {
        key: 'start',
        value: function start(tracerImp) {
            if (!this._enabled) {
                return;
            }
            this._tracer = tracerImp;

            var currentOptions = tracerImp.options();
            this._addServiceHostToExclusions(currentOptions);
            this._handleOptions({}, currentOptions);
            tracerImp.on('options', this._handleOptions);
        }
    }, {
        key: 'stop',
        value: function stop() {
            if (!this._enabled) {
                return;
            }
            _http2.default.request = proxiedHttpRequest;
            _http2.default.get = proxiedHttpGet;

            _https2.default.request = proxiedHttpsRequest;
            _https2.default.get = proxiedHttpsGet;
        }

        /**
         * Respond to options changes on the Tracer.
         *
         * Note that `modified` is the options that have changed in this call,
         * along with their previous and new values. `current` is the full set of
         * current options *including* the newly modified values.
         */

    }, {
        key: '_handleOptions',
        value: function _handleOptions(modified, current) {
            // Automatically add the service host itself to the list of exclusions
            // to avoid reporting on the reports themselves
            var serviceHost = modified.collector_host;
            if (serviceHost) {
                this._addServiceHostToExclusions(current);
            }

            // Set up the proxied fetch calls unless disabled
            if (!this._proxyInited && current.nodejs_instrumentation) {
                this._proxyInited = true;
                this._instrumentNodejs();
            }
        }

        /**
         * Ensure that the reports to the collector don't get instrumented as well,
         * as that recursive instrumentation is more confusing than valuable!
         */

    }, {
        key: '_addServiceHostToExclusions',
        value: function _addServiceHostToExclusions(opts) {
            if (opts.collector_host.length === 0) {
                return;
            }

            // http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
            function escapeRegExp(str) {
                return ('' + str).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            // Check against the hostname without the port as well as the canonicalized
            // URL may drop the standard port.
            var host = escapeRegExp(opts.collector_host);
            var port = escapeRegExp(opts.collector_port);
            var set = [new RegExp('^https?://' + host + ':' + port)];
            if (port === '80') {
                set.push(new RegExp('^http://' + host));
            } else if (port === '443') {
                set.push(new RegExp('^https://' + host));
            }
            this._internalExclusions = set;
        }

        /**
         * Check if in node
         */

    }, {
        key: '_isValidContext',
        value: function _isValidContext() {
            var isNode = typeof process !== 'undefined' && typeof process.release !== 'undefined' && process.release.name === 'node';
            return isNode;
        }
    }, {
        key: '_instrumentNodejs',
        value: function _instrumentNodejs() {
            var self = this;
            var tracer = this._tracer;

            function requestOverride(originalRequest) {
                // http.request has two overrides, taking url/string first, or options
                // if url or string morph into an options object,
                // make it so that options and possible callback are only args passed
                var options = void 0;
                var callback = void 0;
                var urlObject = void 0;
                /* eslint-disable prefer-destructuring */

                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                }

                if (typeof args[0] === 'string' || args[0] instanceof _url.URL) {
                    urlObject = args[0] instanceof _url.URL ? args[0] : new _url.URL(args[0]);
                    options = urlToOptions(urlObject);
                    if (_typeof(args[1]) === 'object') {
                        options = _extends({}, options, args[1]);
                        callback = args[2];
                    } else if (typeof args[1] === 'function') {
                        callback = args[1];
                    }
                } else {
                    options = args[0];
                    callback = args[1];
                }
                /* eslint-enable prefer-destructuring */

                // check if there are headers stated, and if not create them on the first arg
                // then grab reference so that we can inject headers into the request before sending the request out
                if (!options.headers) options.headers = {};

                var _options = options;
                var headers = _options.headers;

                var method = options.method || 'GET';
                var url = options.href || _url2.default.format(options);
                var protocol = options.protocol ? options.protocol.replace(':', '') : url.slice(0, url.indexOf(':'));
                if (!self._shouldTrace(tracer, url)) {
                    return originalRequest.apply(undefined, args);
                }

                var span = tracer.startSpan('node request');
                tracer.addActiveRootSpan(span);

                var tags = {
                    method: method || 'GET',
                    url: url,
                    protocol: protocol
                };
                if (url) {
                    // eslint-disable-next-line prefer-destructuring
                    tags.url_pathname = url.split('?')[0];
                }

                try {
                    var headersCarrier = {};
                    tracer.inject(span.context(), opentracing.FORMAT_HTTP_HEADERS, headersCarrier);
                    var keys = Object.keys(headersCarrier);
                    // add tracing headers to request
                    // have to set headers instead of modifying the request instance headers,
                    // In an http.get call case, req.end will automatically be called,
                    // setting headers will be impossible after that point
                    // reference https://nodejs.org/api/http.html#http_class_http_clientrequest
                    keys.forEach(function (key) {
                        headers[key] = headersCarrier[key];
                    });
                    var request = originalRequest(options, callback);

                    span.log({
                        event: 'sending',
                        method: method || 'GET',
                        url: url,
                        openPayload: tags
                    });
                    span.addTags(tags);

                    request.on('response', function (res) {
                        if (res.statusCode >= 500 && res.statusCode <= 599) {
                            span.addTags({ error: true });
                        }
                        span.log({
                            method: method || 'GET',
                            headers: res.headers,
                            status: res.status,
                            statusText: res.statusText,
                            responseType: res.type,
                            url: res.url
                        });
                        span.finish();
                        tracer.removeActiveRootSpan(span);
                    });

                    return request;
                } catch (e) {
                    span.addTags({ error: true });
                    tracer.removeActiveRootSpan(span);
                    span.log({
                        event: 'error',
                        error: e
                    });
                    span.finish();
                    throw e;
                }
            }

            _http2.default.request = requestOverride.bind(undefined, _http2.default.request);
            _https2.default.request = requestOverride.bind(undefined, _https2.default.request);

            _http2.default.get = requestOverride.bind(undefined, _http2.default.get);
            _https2.default.get = requestOverride.bind(undefined, _https2.default.get);
        }
    }, {
        key: '_shouldTrace',
        value: function _shouldTrace(tracer, url) {
            // This shouldn't be possible, but let's be paranoid
            if (!tracer || !url) {
                return false;
            }

            var opts = tracer.options();
            if (opts.disabled || !opts.nodejs_instrumentation) {
                return false;
            }

            if (this._internalExclusions.some(function (ex) {
                return ex.test(url);
            })) {
                return false;
            }

            var include = false;
            if (opts.nodejs_url_inclusion_patterns.some(function (inc) {
                return inc.test(url);
            })) {
                include = true;
            }
            if (opts.nodejs_url_exclusion_patterns.some(function (ex) {
                return ex.test(url);
            })) {
                include = false;
            }
            return include;
        }
    }]);

    return InstrumentNodejs;
}();

module.exports = new InstrumentNodejs();

//# sourceMappingURL=instrument_nodejs.js.map