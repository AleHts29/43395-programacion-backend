'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _opentracing = require('opentracing');

var opentracing = _interopRequireWildcard(_opentracing);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Capture the proxied values on script load (i.e. ASAP) in case there are
// multiple layers of instrumentation.
var proxiedFetch = void 0;
if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && typeof window.fetch !== 'undefined') {
    proxiedFetch = window.fetch;
}

function getCookies() {
    if (typeof document === 'undefined' || !document.cookie) {
        return null;
    }
    var cookies = document.cookie.split(';');
    var data = {};
    var count = 0;
    for (var i = 0; i < cookies.length; i++) {
        var parts = cookies[i].split('=', 2);
        if (parts.length === 2) {
            var key = parts[0].replace(/^\s+/, '').replace(/\s+$/, '');
            data[key] = decodeURIComponent(parts[1]);
            try {
                data[key] = JSON.parse(data[key]);
            } catch (_ignored) {/* Ignored */}
            count++;
        }
    }
    if (count > 0) {
        return data;
    }
    return null;
}

// Normalize the getAllResponseHeaders output
function getResponseHeaders(response) {
    var result = {};
    var entries = response.headers.entries();
    for (var i = 0; i < entries.length; i++) {
        var pair = entries[i];

        var _pair = _slicedToArray(pair, 2);

        var key = _pair[0];
        var val = _pair[1];

        result[key] = val;
    }
    return result;
}

// Automatically create spans for all requests made via window.fetch.
//
// NOTE: this code currently works only with a single Tracer.
//

var InstrumentFetch = function () {
    function InstrumentFetch() {
        _classCallCheck(this, InstrumentFetch);

        this._enabled = this._isValidContext();
        this._proxyInited = false;
        this._internalExclusions = [];
        this._tracer = null;
        this._handleOptions = this._handleOptions.bind(this);
    }

    _createClass(InstrumentFetch, [{
        key: 'name',
        value: function name() {
            return 'instrument_fetch';
        }
    }, {
        key: 'addOptions',
        value: function addOptions(tracerImp) {
            tracerImp.addOption('fetch_instrumentation', { type: 'bool', defaultValue: false });
            tracerImp.addOption('fetch_url_inclusion_patterns', { type: 'array', defaultValue: [/.*/] });
            tracerImp.addOption('fetch_url_exclusion_patterns', { type: 'array', defaultValue: [] });
            tracerImp.addOption('fetch_url_header_inclusion_patterns', { type: 'array', defaultValue: [/.*/] });
            tracerImp.addOption('fetch_url_header_exclusion_patterns', { type: 'array', defaultValue: [] });
            tracerImp.addOption('include_cookies', { type: 'bool', defaultValue: true });
        }
    }, {
        key: 'start',
        value: function start(tracerImp) {
            if (!this._enabled) {
                return;
            }
            this._tracer = tracerImp;

            var currentOptions = tracerImp.options();
            this._addServiceHostToExclusions(currentOptions);
            this._handleOptions({}, currentOptions);
            tracerImp.on('options', this._handleOptions);
        }
    }, {
        key: 'stop',
        value: function stop() {
            if (!this._enabled) {
                return;
            }
            window.fetch = proxiedFetch;
        }

        /**
         * Respond to options changes on the Tracer.
         *
         * Note that `modified` is the options that have changed in this call,
         * along with their previous and new values. `current` is the full set of
         * current options *including* the newly modified values.
         */

    }, {
        key: '_handleOptions',
        value: function _handleOptions(modified, current) {
            // Automatically add the service host itself to the list of exclusions
            // to avoid reporting on the reports themselves
            var serviceHost = modified.collector_host;
            if (serviceHost) {
                this._addServiceHostToExclusions(current);
            }

            // Set up the proxied fetch calls unless disabled
            if (!this._proxyInited && current.fetch_instrumentation) {
                this._proxyInited = true;
                window.fetch = this._instrumentFetch();
            }
        }

        /**
         * Ensure that the reports to the collector don't get instrumented as well,
         * as that recursive instrumentation is more confusing than valuable!
         */

    }, {
        key: '_addServiceHostToExclusions',
        value: function _addServiceHostToExclusions(opts) {
            if (opts.collector_host.length === 0) {
                return;
            }

            // http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
            function escapeRegExp(str) {
                return ('' + str).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            // Check against the hostname without the port as well as the canonicalized
            // URL may drop the standard port.
            var host = escapeRegExp(opts.collector_host);
            var port = escapeRegExp(opts.collector_port);
            var set = [new RegExp('^https?://' + host + ':' + port)];
            if (port === '80') {
                set.push(new RegExp('^http://' + host));
            } else if (port === '443') {
                set.push(new RegExp('^https://' + host));
            }
            this._internalExclusions = set;
        }

        /**
         * Check preconditions for the auto-instrumentation of fetch to work properly.
         * There are a lot of potential JavaScript platforms.
         */

    }, {
        key: '_isValidContext',
        value: function _isValidContext() {
            if (typeof window === 'undefined') {
                return false;
            }
            if (!window.fetch) {
                return false;
            }
            return true;
        }
    }, {
        key: '_instrumentFetch',
        value: function _instrumentFetch() {
            var self = this;
            var tracer = this._tracer;

            return function (input, init) {
                var request = new Request(input, init);
                var opts = tracer.options();

                if (!self._shouldTrace(tracer, request.url)) {
                    // eslint-disable-next-line prefer-spread
                    return proxiedFetch(request);
                }

                var span = tracer.startSpan('fetch');
                tracer.addActiveRootSpan(span);

                var parsed = new URL(request.url);
                var tags = {
                    method: request.method,
                    url: request.url,

                    // NOTE: Purposefully excluding username:password from tags.
                    // TODO: consider sanitizing URL to mask / remove that information from the trace in general
                    hash: parsed.hash,
                    href: parsed.href,
                    protocol: parsed.protocol,
                    origin: parsed.origin,
                    host: parsed.host,
                    hostname: parsed.hostname,
                    port: parsed.port,
                    pathname: parsed.pathname,
                    search: parsed.search
                };
                if (opts.include_cookies) {
                    tags.cookies = getCookies();
                }

                // Add Open-Tracing headers
                if (self._shouldAddHeadersToRequest(tracer, request.url)) {
                    var headersCarrier = {};
                    tracer.inject(span.context(), opentracing.FORMAT_HTTP_HEADERS, headersCarrier);
                    Object.keys(headersCarrier).forEach(function (key) {
                        if (!request.headers.get(key)) request.headers.set(key, headersCarrier[key]);
                    });
                }
                span.log({
                    event: 'sending',
                    method: request.method,
                    url: request.url,
                    openPayload: tags
                });
                span.addTags(tags);

                return proxiedFetch(request).then(function (response) {
                    if (!response.ok) {
                        span.addTags({ error: true });
                    }
                    span.log({
                        method: request.method,
                        headers: getResponseHeaders(response),
                        status: response.status,
                        statusText: response.statusText,
                        responseType: response.type,
                        url: response.url
                    });
                    tracer.removeActiveRootSpan(span);
                    span.finish();
                    return response;
                }).catch(function (e) {
                    span.addTags({ error: true });
                    tracer.removeActiveRootSpan(span);
                    span.log({
                        event: 'error',
                        error: e
                    });
                    span.finish();
                    throw e;
                });
            };
        }
    }, {
        key: '_shouldTrace',
        value: function _shouldTrace(tracer, url) {
            // This shouldn't be possible, but let's be paranoid
            if (!tracer || !url) {
                return false;
            }

            var opts = tracer.options();
            if (opts.disabled) {
                return false;
            }

            if (this._internalExclusions.some(function (ex) {
                return ex.test(url);
            })) {
                return false;
            }

            if (opts.fetch_url_exclusion_patterns.some(function (ex) {
                return ex.test(url);
            })) {
                return false;
            }
            if (opts.fetch_url_inclusion_patterns.some(function (inc) {
                return inc.test(url);
            })) {
                return true;
            }
            return false;
        }
    }, {
        key: '_shouldAddHeadersToRequest',
        value: function _shouldAddHeadersToRequest(tracer, url) {
            // This shouldn't be possible, but let's be paranoid
            if (!tracer || !url) {
                return false;
            }

            var opts = tracer.options();
            if (opts.disabled) {
                return false;
            }

            if (opts.fetch_url_header_exclusion_patterns.some(function (ex) {
                return ex.test(url);
            })) {
                return false;
            }
            if (opts.fetch_url_header_inclusion_patterns.some(function (inc) {
                return inc.test(url);
            })) {
                return true;
            }
            return false;
        }
    }]);

    return InstrumentFetch;
}();

module.exports = new InstrumentFetch();

//# sourceMappingURL=instrument_fetch.js.map